# 3. Программирование общего назначения

Модель программирования общего назначения включает регистры общего назначения (РОН), целочисленные инструкции и операнды, использующие РОН, методы управления потоком программ, методы оптимизации памяти и ввода-вывода. Эта модель программирования включает в себя оригинальную архитектуру x86 с целочисленным программированием, а также 64-битные расширения и несколько дополнительных инструкций. В этой главе описаны только инструкции и ресурсы прикладного программирования. Целочисленные инструкции, обычно используемые в системном программировании, включая все привилегированные инструкции, описаны в томе 2, вместе с другими темами системного программирования.

Модель программирования общего назначения в той или иной степени используется практически всеми программами, включая программы, состоящие в основном из 256- или 128-битных медиа-инструкций, 64-битных медиа-инструкций, инструкций x87 с плавающей точкой или системных инструкций. По этой причине понимание модели программирования общего назначения необходимо для любой работы по программированию с использованием набора инструкций AMD64 архитектуры.

## 3.1 Регистры

На рисунке 3-1 на странице 24 показан обзор регистров, используемых при программировании приложений общего назначения. К ним относятся регистры общего назначения (GPR), сегментные регистры, регистр флагов, и регистр указателей инструкций. Количество и ширина доступных регистров зависит от режима работы.

Регистры и диапазоны регистров, затененные светло-серым цветом на рисунке 3-1 на странице 24, доступны только в 64-битном режиме. Регистры, затененные темно-серым цветом, доступны только в унаследованном режиме и режиме совместимости. Так, в 64-битном режиме 32-битные регистры общего назначения, флаги и указатели команд, доступные в унаследованном режиме и режиме совместимости, расширены до 64-битной ширины, доступны восемь новых GPR, а сегментные регистры DS, ES и SS игнорируются.

При наименовании регистров, если речь идет о нескольких ширинах регистров, используется строчная буква r. Например, обозначение rAX относится к 16-битному AX, 32-битному EAX или 64-битному RAX регистру, в зависимости от эффективного размера операнда инструкции.

<img src="Pasted image 20250629190015.png">

### 3.1.1 Устаревшие регистры

В режимах legacy и compatibility доступны все регистры legacy x86. На рисунке 3-2 на странице 25 показан подробный вид регистров GPR, флагов и указателей инструкций.

<img src="Pasted image 20250629190129.png">

К устаревшим GPRs относятся:
- Восемь 8-битных регистров (AH, AL, BH, BL, CH, CL, DH, DL).
- Восемь 16-битных регистров (AX, BX, CX, DX, DI, SI, BP, SP).
- Восемь 32-битных регистров (EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP).

Размер регистра, используемого инструкцией, зависит от эффективного размера операнда или, для некоторых инструкций, от опкода, размера адреса или размера стека. На рисунке 3-2 16-битные и 32-битные регистры закодированы как от 0 до 7. Для опкодов, задающих байтовый операнд, регистры, закодированные с 0 по 3, относятся к младшим байтовым регистрам (AL, BL, CL, DL), а регистры, закодированные с 4 по 7, - к старшим байтовым регистрам (AH, BH, CH, DH).

16-битный регистр FLAGS, который также является младшими 16 битами 32-битного регистра EFLAGS, показанного на рисунке 3-2, содержит биты управления и состояния, доступные для прикладного программного обеспечения, как описано в разделе 3.1.4, «Регистр флагов», на странице 34. 16-битный регистр указателя инструкции IP или 32-битный регистр указателя инструкции EIP содержит адрес следующей выполняемой инструкции, как описано в разделе 2.5, «Указатель инструкции», на странице 20.

### 3.1.2 64-битный режим регистров

В 64-битном режиме к восьми старым GPR добавляются восемь новых, все 16 GPR имеют ширину 64 бита, а младшие байты всех регистров доступны. На рисунке 3-3 на странице 27 показаны GPR, регистр флагов и регистр указателя инструкции, доступные в 64-битном режиме. К GPR относятся:

- Шестнадцать 8-битных регистров младшего байта (AL, BL, CL, DL, SIL, DIL, BPL, SPL, R8B, R9B, R10B, R11B, R12B, R13B, R14B, R15B).
- Четыре 8-битных регистра старшего байта (AH, BH, CH, DH), адресуемые только при отсутствии префикса REX.
- Шестнадцать 16-битных регистров (AX, BX, CX, DX, DI, SI, BP, SP, R8W, R9W, R10W, R11W, R12W, R13W, R14W, R15W).
- Шестнадцать 32-битных регистров (EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D, R9D, R10D, R11D, R12D, R13D, R14D, R15D).
- Шестнадцать 64-битных регистров (RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP, R8, R9, R10, R11, R12, R13, R14, R15).

Размер регистра, используемого инструкцией, зависит от эффективного размера операнда или, для некоторых инструкций, от опкода, размера адреса или размера стека. Для большинства инструкций доступ к расширенным GPR требует префикса REX (раздел 3.5.2, «Префиксы REX», на странице 79). Четыре старших байта регистра (AH, BH, CH, DH), доступные в унаследованном режиме, не адресуются при использовании префикса REX.

Как правило, байтовые и словесные операнды хранятся в младших 8 или 16 битах GPR без модификации старших 56 или 48 бит, соответственно. Операнды двойного слова, однако, обычно хранятся в младших 32 битах GPR и расширяются до 64 бит.

64-битный регистр RFLAGS, показанный на рисунке 3-3 на странице 27, содержит унаследованный EFLAGS в его младшем 32-битном диапазоне. Старшие 32 бита зарезервированы. В них можно записать что угодно, но они всегда читаются как ноль (read as zero) (RAZ). 64-битный регистр указателя инструкций RIP содержит адрес следующей инструкции, которая должна быть выполнена, как описано в разделе 3.1.5, «Регистр указателя инструкций», на странице 36.

<img src="Pasted image 20250629191427.png">

На рисунке 3-4 на стр. 28 показан другой способ просмотра GPRs в 64-битном режиме, где показано, как устаревшие GPRs накладываются на расширенные GPRs. Затененные серым биты не изменяются в 64-битном режиме.

<img src="Pasted image 20250629191617.png">

#### 3.1.2.1 Стандартный размер операнда

Для большинства инструкций размер операнда по умолчанию в 64-битном режиме составляет 32 бита. Для доступа к 16-битному операнду инструкция должна содержать префикс размера операнда (66h), как описано в разделе 3.2.3, «Размеры операнда и переопределения», на странице 41. Чтобы получить доступ к полному 64-битному размеру операнда, большинство инструкций должны содержать префикс REX. 

Подробнее о размерах операндов см. в разделе 3.2.3, «Размеры операндов и переопределения», на странице 41. 

#### 3.1.2.2 Байтовые регистры

64-битный режим обеспечивает единообразный набор регистров младшего байта, младшего слова, младшего двойного слова и четверного слова, что хорошо подходит для распределения регистров компиляторами. Для доступа к четырем новым младшим байтовым регистрам в унаследованном диапазоне GPR (SIL, DIL, BPL, SPL) или к любому из младших байтовых регистров в расширенных регистрах (R8B-R15B) требуется префикс инструкции REX. Однако старшие байтовые регистры (AH, BH, CH, DH) недоступны при использовании префикса REX.

#### 3.1.2.3 Нулевое расширение 32-разрядных результатов

Как показано на Рисунке 3-3 на стр. 27 и Рисунке 3-4 на стр. 28, при выполнении 32-битных операций с GPR-адресатом в 64-битном режиме процессор обнуляет 32-битный результат и расширяет его до полного 64-битного адресата. 8- и 16-битные операции над GPR сохраняют все незаписанные старшие биты GPR назначения. Это соответствует устаревшей 16- и 32-битной семантике для результатов неполной ширины.

Программное обеспечение должно явно расширить по знаку результаты 8-, 16- и 32-битных операций до полной ширины 64-бит, прежде чем использовать их в вычислениях 64-битных адресов.

Следующие четыре примера кода показывают, как работают 64-битные, 32-битные, 16-битные и 8-битные ADD. В этих примерах «48» - это REX-префикс, указывающий на 64-битный размер операнда, а «01C3» и «00C3» - это опкод и байт ModRM каждой инструкции (подробности об опкоде и кодировке ModRM см. в разделе «Синтаксис опкодов» в томе 3).

*Пример 1: 64-битное сложение:*

```
Before:RAX =0002_0001_8000_2201 
	RBX =0002_0002_0123_3301 
	48 01C3 ADD RBX,RAX ;48 - это REX-префикс для обозначения размера. 
Result:RBX = 0004_0003_8123_5502
```

*Пример 2: 32-битное сложение:*

```
Before:RAX = 0002_0001_8000_2201 
	RBX = 0002_0002_0123_3301 
	01C3 ADD EBX,EAX ;32-bit add 
Result:RBX = 0000_0000_8123_5502 
	(32-bit result is zero extended)
```

*Пример 3: 16-битное сложение:*

```
Before:RAX = 0002_0001_8000_2201 
	RBX = 0002_0002_0123_3301 
	66 01C3 ADD BX,AX ;66 - переопределение 16-битного размера 
Result:RBX = 0002_0002_0123_5502 
	(bits 63:16 are preserved)
```

*Пример 4: 8-битное сложение:*

```
Before:RAX = 0002_0001_8000_2201 
	RBX = 0002_0002_0123_3301 
	00C3 ADD BL,AL ;8-bit add 
Result:RBX = 0002_0002_0123_3302 
	(bits 63:08 are preserved)
```

#### 3.1.2.4 Старшие 32-бита GPR для переключения режимов

Процессор не сохраняет старшие 32 бита 64-битных GPR при переходе из 64-битного режима в режимы совместимости или устаревшие режимы. При использовании 32-битных операндов в режиме совместимости или устаревшем режиме старшие 32 бита GPRs не определены. Программное обеспечение не должно полагаться на эти неопределенные биты, поскольку они могут меняться от одной реализации к другой или даже от цикла к циклу в рамках одной реализации. Неопределенные биты не являются функцией данных, оставленных каким-либо ранее запущенным процессом.

### Неявное использование GPRs

Большинство инструкций могут использовать любой из GPR для операндов. Однако, как показано на рисунке 3-1 на странице 31, некоторые инструкции используют некоторые GPR неявно. Подробности о неявном использовании GPR описаны в разделе «Инструкции общего назначения в 64-разрядном режиме» в томе 3.

В таблице 3-1 на странице 31 показано неявное использование регистров только для прикладных инструкций. Некоторые системные инструкции также неявно используют регистры. Эти системные инструкции описаны в разделе «Справочник системных инструкций» в томе 3.

<img src="Pasted image 20250629193940.png">

<img src="Pasted image 20250629194015.png">

#### 3.1.3.1 Арифметические операции

Некоторые формы инструкций сложения, вычитания, умножения и деления неявно используют AL или rAX. Инструкции умножения и деления также используют конкатенацию rDX:rAX для получения результатов двойного размера (при умножении), или кванта и остатка (при делении).

#### 3.1.3.2 Расширение знаком

Инструкции, удваивающие размер операндов за счет расширения знака (например, CBW, CWDE, CDQE, CWD, CDQ, CQO), неявно используют регистр rAX для операнда. Инструкции CWD, CDQ и CQO также используют регистр rDX.

#### 3.1.3.3 Специальные MOV

Инструкция MOV имеет несколько опкодов, которые неявно используют регистр AL или rAX для одного операнда.

#### 3.1.3.4 Строковые операции

Многие типы строковых инструкций используют аккумуляторы неявно. Строковые инструкции load string, store string и scan используют AL или rAX для данных и rDI или rSI для смещения адреса памяти.

#### 3.1.3.5 Операции ввода-вывода адресного пространства.

Инструкции ввода/вывода и строкового ввода/вывода используют rAX для хранения данных, которые принимаются от устройства, расположенного в пространстве адресов ввода/вывода, или отправляются на него. DX содержит адрес устройства ввода-вывода (номер порта).

#### 3.1.3.6 Таблицы перемещений

Инструкция перемещения таблицы (XLATB) использует AL для индекса памяти и rBX для базового адреса памяти.

#### 3.1.3.7 Сравнение и обмен

Инструкции сравнения и обмена (CMPXCHG) используют регистр AL или rAX для одного операнда

#### 3.1.3.8 Десятичная арифметика

Инструкции десятичной арифметики (AAA, AAD, AAM, AAS, DAA, DAS), которые корректируют двоично-кодированные десятичные (BCD) операнды, неявно используют регистр AL и AH для своих операций.

#### 3.1.3.9 Сдвиги и повороты

Инструкции Shift и Rotate могут использовать регистр CL для указания количества битов операнда, который должен быть сдвинут или повернут.

#### 3.1.3.10 Условные переходы

Специальные инструкции условного перехода используют регистр rCX вместо флагов. Инструкции JCXZ и JrCXZ проверяют значение регистра rCX и передают управление целевой инструкции, когда значение регистра rCX достигает 0.

#### 3.1.3.11 Повторяющиеся операции со строками

За исключением строковых инструкций ввода/вывода, все строковые операции используют rSI в качестве указателя операнда-источника и rDI в качестве указателя операнда назначения. Строковые инструкции ввода/вывода используют rDX для указания номера входного порта или выходного порта. Для повторяющихся строковых операций (перед которыми стоит префикс repeat-instruction) регистры rSI и rDI инкрементируются или декрементируются по мере перемещения элементов строки из места-источника в место назначения. Операции повторения строки также используют регистр rCX для хранения длины строки, а регистр уменьшает ее по мере перемещения данных из одного места в другое.

#### 3.1.3.12 Операции со стеками

При операциях со стеком неявно используется регистр rSP, а в некоторых случаях и регистр rBP. Регистр rSP используется для хранения указателя вершины стека (или просто указателя стека). rSP декрементируется, когда элементы заталкиваются в стек, и инкрементируется, когда они выгружаются из стека. Инструкции ENTER и LEAVE используют rBP в качестве базового указателя стека. Здесь rBP указывает на последнюю запись в структуре данных, которая передается от одной процедуры с блочной структурой к другой.

Использование rSP или rBP в качестве базового регистра при вычислении адреса подразумевает использование SS (сегмента стека) в качестве сегмента по умолчанию. Использование любого другого GPR в качестве базового регистра без префикса переопределения сегмента подразумевает использование сегмента данных DS в качестве сегмента по умолчанию.

Инструкции push all и pop all (PUSHA, PUSHAD, POPA, POPAD) неявно используют все GPR.

#### 3.1.3.13 Информация о CPUID

Инструкция CPUID неявно использует регистры EAX, EBX, ECX и EDX. Программа загружает код функции в EAX и, для некоторых кодов функций, код подфункции в ECX, выполняет инструкцию CPUID, а затем считывает связанную с ней информацию о характеристиках процессора в EAX, EBX, ECX и EDX.

### 3.1.4 Регистр флагов

На рисунке 3-5 на странице 34 показан 64-битный регистр RFLAGS и биты флагов, видимые прикладным программным обеспечением. Биты 15:0 - это регистр FLAGS (доступ в унаследованных реальном и виртуальном режимах 8086), биты 31:0 - регистр EFLAGS (доступ в унаследованном защищенном режиме и режиме совместимости), а биты 63:0 - регистр RFLAGS (доступ в 64-битном режиме). Название *rFLAGS* относится к любому из трех регистров, в зависимости от текущего программного контекста.

<img src="Pasted image 20250629200707.png">

Младшие 16 бит (часть FLAGS) rFLAGS доступны прикладному программному обеспечению и содержат следующие флаги:

* Один флаг управления (флаг направления DF)
* Шесть флагов состояния (флаг переноса CF, флаг четности PF, флаг вспомогательного переноса AF, флаг нуля ZF, флаг знака SF, и флаг переполнения OF).

Флаг направления (DF) управляет направлением строковых операций. Флаги состояния предоставляют информацию о результатах логических и арифметических операций и управляющую информацию для инструкций условного перемещения и перехода.

Биты 31:16 регистра rFLAGS содержат флаги, доступные только системному программному обеспечению. Эти флаги описаны в разделе «Системные регистры» в томе 2. Старшие 32 бита RFLAGS зарезервированы.
В 64-битном режиме записи в эти биты игнорируются. Они считываются как нули (RAZ). При сбросе регистр rFLAGS по адресу инициализируется значением 02h, поэтому все программируемые биты очищаются до нуля.

Эффекты, которые битовые значения rFLAGS оказывают на инструкции, кратко описаны в следующих местах:

- Условные перемещения (CMOVcc)-Таблица 3-4 на странице 46.
- Условные прыжки (Jcc)-Таблица 3-5 на странице 60.
- Условные наборы (SETcc)-Таблица 3-6 на странице 64.

Влияние инструкций на битовые значения rFLAGS кратко описано в разделе «Влияние инструкций на RFLAGS» в томе 3.

В следующих разделах описывается каждый флаг, видимый приложением. Все эти флаги доступны для чтения и записи. Например, инструкции POPF, POPFD, POPFQ, IRET, IRETD и IRETQ записывают все флаги. Флаги переноса и направления могут быть записаны специальными прикладными инструкциями. Другие флаги, видимые приложением, записываются косвенно специальными инструкциями. Зарезервированные биты и биты, запись которых запрещена текущими значениями системных флагов, текущим уровнем привилегий (CPL) или текущим режимом работы, не затрагиваются инструкциями POPFx.

**Флаг переноса** **(CF)**. Бит 0. Аппаратные средства устанавливают флаг переноса в 1, если последняя операция целочисленного сложения или вычитания привела к переносу (для сложения) или заимствованию (для вычитания) из старшего значащего бита позиции результата. В противном случае аппаратные средства очищают флаг до 0. 

Инкремент и декремент, в отличие от сложения и вычитания, не влияют на флаг переноса. Инструкции сдвига и поворота битов сдвигают биты операндов во флаг переноса. Логические инструкции, такие как AND, OR, XOR, снимают флаг переноса. Инструкции проверки битов (BTx) устанавливают значение флага переноса в зависимости от значения проверяемого бита операнда.

Программное обеспечение может установить или снять флаг переноса с помощью инструкций STC и CLC соответственно. Программа может дополнить флаг инструкцией CMC.

**Флаг четности (PF)**. Бит 2. Аппаратные средства устанавливают флаг четности в 1, если в наименее значащем байте последнего результата определенных операций имеется четное количество битов 1. В противном случае (т. е. при нечетном количестве битов 1) аппаратура сбрасывает флаг в 0. Программное обеспечение может считывать флаг для реализации проверки четности.

**Флаг вспомогательного переноса (AF)**. Бит 4. Аппаратные средства устанавливают флаг вспомогательного переноса, если при выполнении арифметической операции или операции двоично-десятичного кодирования (BCD) из бита 3 результата генерируется перенос (в случае сложения) или заимствование (в случае вычитания). В противном случае AF очищается до нуля.

Основное применение этого флага - поддержка десятичных арифметических операций. Чаще всего этот флаг используется внутренними командами коррекции для десятичного сложения (AAA) и вычитания (AAS).

**Флаг нуля (ZF)**. Бит 6. Аппаратные средства устанавливают флаг нуля в 1, если последняя арифметическая операция привела к значению, равному нулю. В противном случае (при ненулевом результате) аппаратные средства очищают флаг до 0. Инструкции compare и test также влияют на нулевой флаг.

Флаг нуля обычно используется для проверки того, равен ли нулю результат арифметической или логической операции, или для проверки того, равны ли два операнда.

**Флаг знака (SF)**. Бит 7. Аппаратные средства устанавливают флаг знака в 1, если последняя арифметическая операция привела к отрицательному значению. В противном случае (для результата с положительным значением) аппаратные средства очищают флаг до 0. Таким образом, в таких операциях значение флага знака устанавливается равным значению самого значащего бита результата.
В зависимости от размера операндов, старший бит - это бит 7 (для байтов), бит 15 (для слов), бит 31 (для двойных слов) или бит 63 (для четверных слов).

**Флаг направления (DF)**. Бит 10. Флаг направления определяет порядок обработки строк. Программа может установить флаг направления в 1, чтобы задать декремент указателя данных для следующей инструкции (LODSx, STOSx, MOVSx, SCASx, CMPSx, OUTSx или INSx). Сброс флага направления в 0 означает инкрементирование указателя данных. Указатели хранятся в регистре rSI или rDI. Программа может установить или снять флаг с помощью инструкций STD и CLD соответственно.

**Флаг переполнения (OF)**. Бит 11. Аппаратные средства устанавливают флаг переполнения в 1, чтобы указать, что старший значащий (знаковый) бит результата последней операции со знаковыми целыми числами отличается от знаков обоих исходных операндов. В противном случае аппаратные средства очищают флаг до 0. Установленный флаг переполнения означает, что величина положительного или отрицательного результата слишком велика (переполнение) или слишком мала (недополнение), чтобы соответствовать определенному типу данных.

Флаг OF не определен после выполнения инструкции DIV и после сдвига более чем на один бит. Логические инструкции снимают флаг переполнения.

### 3.1.5 Регистр указателя инструкций

Регистр указателя инструкций - IP, EIP или RIP, или просто rIP для любого из трех в зависимости от контекста используется вместе с регистром кодового сегмента (CS) для определения местоположения следующей инструкции в памяти. Подробности см. в разделе 2.5, «Указатель инструкции», на стр. 20.

## 3.2 Операнды

Операнды либо ссылаются в кодировке инструкции, либо включаются в качестве немедленного значения в кодировку инструкции. В зависимости от инструкции, ссылаемые операнды могут располагаться в регистрах, ячейках памяти или портах ввода/вывода.

### 3.2.1 Основные типы данных

На самом фундаментальном уровне данные - это упорядоченная строка определенной длины, состоящая из двоичных цифр (битов). Биты индексируются от 0 до длины-1. Хотя технически размер данных не ограничен, для удобства хранения и манипулирования данными в архитектуре определено конечное число объектов данных определенного размера и даны их названия.

Данные длины 1 - это просто бит. Данные длины 4 - это ниббл, данные длины 8 - это байт, данные длины 16 - это слово, данные длины 32 - это двойное слово, данные длины 64 - это четырехсловное слово, данные длины 128 - это двойное четырехсловное слово (также называемое октословом), данные длины 256 - это двойное октослово.

Для инструкций, перемещающих или переупорядочивающих данные, значение каждого бита внутри массива данных несущественно. Инструкции такого типа могут работать с битами, байтами, словами, двойными словами и так далее. Большинство инструкций, однако, ожидают, что данные операнда будут иметь определенный формат. Формат присваивает каждому биту определенное значение, основанное на его положении в массиве данных. Такое присвоение значимости или смысла каждому биту называется типизацией данных.

Архитектура определяет следующие основные типы данных:
* Не типизированные объекты данных
	- bit 
	- nibble (4 bits) 
	- byte (8 bits)
	- word (16 bits)
	- doubleword (32 bits)
	- quadword (64 bits)
	- double quadword (octword) (128 bits)
	- double octword (256 bits)
- Целые беззнаковые числа
	- 8-bit (byte) unsigned integer 
	- 16-bit (word) unsigned integer 
	- 32-bit (doubleword) unsigned integer 
	- 64-bit (quadword) unsigned integer 
	- 128-bit (octword) unsigned integer
- Знаковые (двухкомпонентные) целые числа
	- 8-bit (byte) signed integer 
	- 16-bit (word) signed integer 
	- 32-bit (doubleword) signed integer 
	- 64-bit (quadword) signed integer 
	- 128-bit (octword) signed integer
- Двоично-кодированные десятичные (BCD) цифры
- Типы данных с плавающей точкой
	- half-precision floating point (16 bits) 
	- single-precision floating point (32 bits) 
	- double-precision floating point (64 bits)

Эти фундаментальные типы данных могут быть объединены в составные типы данных. Определенными составными типами данных являются:

* Строки
	- символьные строки (состоящие из байтов или слов)
	- doubleword и quadword
- Упакованный BCD
- Упакованные целые числа со знаком и без знака (также называемые целочисленными векторами)
- Упакованные векторы с плавающей точкой одинарной или двойной точности (также называемые векторами с плавающей точкой)

Целочисленные, BCD и строковые типы данных описаны в следующем разделе. Типы данных векторов с плавающей точкой и рассматриваются в разделе 4.3.3, «Типы данных инструкций SSE», на странице 121.

