# 2. Модель памяти

## 2.1 Организация памяти

### 2.1.1 Виртуальная память

Виртуальная память состоит из всего адресного пространства, доступного программам. Это большое линейно-адресное пространство, которое преобразуется комбинацией аппаратных средств и программного обеспечения операционной системы в меньшее физическое адресное пространство, часть которого находится в памяти, а часть - на диске или другом внешнем носителе.

На рисунке 2-1 на странице 10 показано, как обрабатывается пространство виртуальной памяти в двух подрежимах длинного режима:

- *64-битный режим* - в этом режиме используется модель плоской сегментации виртуальной памяти. 64-битное пространство виртуальной памяти рассматривается как единое, плоское (несегментированное) адресное пространство. Адреса программы обращаются к местам, которые могут находиться в любом месте линейного 64-битного адресного пространства. Операционная система может использовать отдельные селекторы для сегментов кода, стека и данных в целях защиты памяти, но базовый адрес всех этих сегментов всегда равен 0. (Исключение из этого общего правила см. в разделе «FS и GS как база для вычисления адреса» на странице 17).

- *Режим совместимости* - в этом режиме используется защищенная многосегментная модель виртуальной памяти, как и в унаследованном защищенном режиме. 32-битное пространство виртуальной памяти рассматривается как сегментированный набор адресных пространств для сегментов кода, стека и данных, каждый из которых имеет свой базовый адрес и параметры защиты. Сегментированное пространство задается путем добавления к адресу селектора сегмента.

<img src="./Pasted image 20250629145705.png" >

Операционные системы используют сегментированную память как метод изоляции программ от данных, которые они используют, в попытке повысить надежность систем, в которых одновременно работают несколько программ. Однако большинство современных операционных систем не используют возможности сегментации, доступные в устаревшей архитектуре x86. Вместо этого эти операционные системы выполняют функции сегментации полностью программно. По этой причине архитектура AMD64 в 64-битном режиме обходится без большинства унаследованных функций сегментации. Это позволяет более просто кодировать 64-битные операционные системы и поддерживает более эффективное управление многозадачными средами, чем это возможно в устаревшей архитектуре x86.

### 2.1.2 Сегментные регистры

Сегментные регистры содержат селекторы, используемые для доступа к сегментам памяти. На рисунке 2-2 на странице 11 показана видимая приложению часть сегментных регистров. В унаследованном режиме и режиме совместимости все сегментные регистры доступны для программного обеспечения. В 64-битном режиме процессор распознает только сегменты CS, FS и GS, и программы могут использовать базовые регистры сегментов FS и GS в качестве базовых регистров для вычисления адреса, как описано в разделе «FS и GS как база для вычисления адреса» на странице 17. Для обращений к сегментам DS, ES или SS в 64-битном режиме процессор предполагает, что база каждого из этих сегментов равна нулю, не проверяются ни границы сегментов, ни их атрибуты, и процессор просто проверяет, что все такие адреса имеют каноническую форму, как описано в разделе «64-битные канонические адреса» на странице 15.

<img src="Pasted image 20250629150519.png" >

### 2.1.3 Физическая память

Физическая память - это установленная память (за исключением кэш-памяти) в конкретной компьютерной системе, доступ к которой возможен через шинный интерфейс процессора. Максимальный размер пространства физической памяти определяется с помощью адресных битов на шинном интерфейсе. В системе виртуальной памяти большое виртуальное адресное пространство (также называемое линейным адресным пространством) преобразуется в меньшее физическое адресное пространство с помощью комбинации аппаратных и программных средств сегментации и подкачки.

Сегментация показана на рисунке 2-1 на странице 10. Пейджинг - это механизм преобразования линейных (виртуальных) адресов в блоки фиксированного размера, называемые страницами, которые операционная система может перемещать по мере необходимости между памятью и внешними носителями (обычно дисками). Архитектура AMD64 поддерживает расширенную версию устаревшего механизма подкачки x86, которая способна преобразовывать полное 64-битное виртуальное адресное пространство в физическое адресное пространство, поддерживаемое конкретной реализацией.

### 2.1.4 Управление памятью

Стратегии управления памятью переводят адреса, генерируемые программами, в адреса в физической памяти с помощью сегментации и/или подкачки. Управление памятью не видно прикладным программам. Им занимаются операционная система и аппаратное обеспечение процессора. Ниже приводится очень краткий обзор этих функций. Более подробная информация приведена в разделе «Инструкции системного управления» в томе 2.

#### 2.1.4.1 Управление памятью в длинном режиме

На рисунке 2-3 показан поток, сверху вниз, функций управления памятью, выполняемых в двух подрежимах длинного режима.

<img src="Pasted image 20250629151331.png" >

В 64-битном режиме программы генерируют виртуальные (линейные) адреса, размер которых может достигать 64 бит. Виртуальные адреса передаются функции подкачки в длинном режиме, которая генерирует физические адреса, размер которых может достигать 52 бит. (Конкретные реализации архитектуры могут поддерживать меньшие размеры виртуальных и физических адресов).

В режиме совместимости устаревшие 16- и 32-битные приложения работают с использованием семантики сегментации в защищенном режиме x86. 16- или 32-битные эффективные адреса, генерируемые программами, объединяются с их сегментами для получения 32-битных виртуальных (линейных) адресов, которые расширяются до нуля и составляют максимум 64 бита. Последующая подкачка - это та же функция подкачки в длинном режиме, которая используется в 64-битном режиме. Она преобразует виртуальные адреса в физические. Комбинация селектора сегмента и эффективного адреса также называется *логическим адресом* или *дальним указателем*. *Виртуальный адрес* также называется линейным адресом.

#### 2.1.4.2 Управление памяти в устаревшем режиме (Legacy mode)

На рисунке 2-4 на странице 13 показаны функции управления памятью, выполняемые в трех подрежимах устаревшего режима.

<img src="Pasted image 20250629152126.png" >

В зависимости от подрежима функции управления памятью различаются следующим образом:
- *Защищенный режим* - защищенный режим поддерживает 16- и 32-битные программы с табличной сегментацией памяти, подкачкой и проверкой привилегий. Функция сегментации принимает 32-битные эффективные адреса и 16-битные селекторы сегментов и выдает 32-битные линейные адреса в один из 16K сегментов памяти, каждый из которых может быть размером до 4 ГБ. Подкачка необязательна. 32-битные физические адреса либо создаются функцией подкачки, либо линейные адреса используются без модификации в качестве физических адресов.
- *Режим Virtual-8086* - режим Virtual-8086 поддерживает 16-разрядные программы, выполняемые как задачи в защищенном режиме. 20-битные линейные адреса формируются так же, как и в реальном режиме, но по желанию могут быть транслированы через функцию подкачки для формирования 32-битных физических адресов, обеспечивающих доступ к памяти объемом до 4 ГБ.
- *Реальный режим* - данный режим поддерживает 16-битные программы, использующие регистровую сегментацию со сдвигом и добавлением, но не поддерживает подкачку. Шестнадцатибитные эффективные адреса расширяются до нуля и добавляются к 16-битному адресу сегмента-базы, который сдвигается на четыре бита влево, в результате чего получается 20-битный линейный адрес. Линейный адрес расширяется до 32-битного физического адреса, по которому можно получить доступ к памяти объемом до 1 МБ.

## 2.2 Адресация памяти

### 2.2.1 Очередь байт

Инструкции и данные хранятся в памяти в *little-endian* порядке байт. Младший порядок помещает наименее значимый байт инструкции или элемента данных по младшему адресу памяти, а наиболее значимый байт - по старшему адресу памяти.

На рисунке 2-5 показано обобщение little-endian памяти и регистровых образов типа данных quadword. Младший байт находится по младшему адресу в памяти и по крайнему правому в образе регистра.

<img src="Pasted image 20250629153001.png">

На рисунке 2-6 на странице 15 показан образ памяти для 10-байтовой инструкции. Инструкции относятся к байтовым типам данных. Они считываются из памяти по одному байту за раз, начиная с наименьшего значащего байта (младшего адреса). Например, следующая инструкция задает 64-битную инструкцию MOV RAX, 1122334455667788, состоящую из следующих десяти байт:

```
48 B8 8877665544332211
```

48 - префикс инструкции REX, задающий 64-битный размер операнда, B8 - опкод, который вместе с префиксом REX определяет 64-битный регистр назначения RAX, а 8877665544332211 - 8-байтовое непосредственное значение для перемещения, где 88 представляет восьмой (наименее значащий) байт, а 11 - первый (наиболее значащий) байт. В памяти байт префикса REX (48) будет храниться по младшему адресу, а первый непосредственный байт (11) - по старшему адресу инструкции

<img src="Pasted image 20250629153308.png" >

### 2.2.2 Каноничные 64-битные адреса

Длинный режим определяет 64 бита виртуального адреса, но реализации архитектуры AMD64 могут поддерживать меньшее количество битов виртуального адреса. Хотя реализации могут не использовать все 64 бита виртуального адреса, они проверяют биты с 63 по самый значимый реализованный бит, чтобы убедиться, что в этих битах все нули или все единицы. Адрес, удовлетворяющий этому свойству, считается *адресом в канонической форме*. Если ссылка на виртуальную память не имеет канонической формы, реализация вызывает исключение общей защиты или ошибку стека.

### 2.2.3 Эффективные адреса

Программы предоставляют эффективные адреса аппаратным средствам до сегментации и трансляции страниц. Эффективные адреса в длинном режиме имеют максимальную ширину 64 бита, как показано на рисунке 2-3 на странице 12.
Программы, работающие в режиме совместимости, генерируют (по умолчанию) 32-битные эффективные адреса, которые аппаратное обеспечение расширяет до 64 бит. Эффективные адреса в режиме Legacy без переопределения размера адреса имеют ширину 32 или 16 бит, как показано на рисунке 2-4 на странице 13. Эти размеры можно изменить с помощью префикса инструкции addresssize, как описано в разделе «Префиксы инструкций» на странице 76.

Существует пять методов генерации эффективных адресов, в зависимости от конкретной инструкции:
* *Абсолютные адреса* - эти адреса задаются как смещения (или сдвиги) от базового адреса сегмента данных. Они указывают непосредственно на ячейку памяти в сегменте данных.
* *Относительные адреса инструкций* - эти адреса задаются как смещения (или сдвиги) от текущего указателя инструкций (IP), также называемого программным счетчиком (PC). Они генерируются инструкциями передачи управления. Смещение в кодировке инструкции или считанное из памяти служит смещением от адреса, следующего за передачей. Подробности о RIP-относительной адресации в 64-битном режиме см. в разделе «RIP-относительная адресация» на стр. 18.
* *Индексированные регистровые адреса* - эти адреса вычисляются по базовому адресу, содержащемуся в регистре общего назначения, указанному в инструкции (base). Различные кодировки позволяют смещение от этой базы с помощью знакового смещения или суммы смещения и масштабированного значения индекса. В кодировках инструкций может использоваться до десяти байт - байт ModRM, дополнительный байт SIB (scale, index, base) и смещение переменной длины - для указания значений, которые будут использоваться при вычислении эффективного адреса. Значения базы и индекса содержатся в регистрах общего назначения, указанных байтом SIB. Значения масштаба и смещения указываются непосредственно в кодировке инструкции. На рисунке 2-7 показаны компоненты вычисления адреса. Полученный эффективный адрес добавляется к базовому адресу сегмента данных для формирования линейного адреса, как описано в разделе «Сегментированная виртуальная память» в томе 2. В разделе «Форматы инструкций» в томе 3 приводится более подробная информация о задании этой формы адреса.

<img src="Pasted image 20250629155412.png" >

- *Адреса стека* - Инструкции PUSH, POP, CALL, RET, IRET и INT неявно используют указатель стека, который содержит адрес стека процедур. Подробности о размере указателя стека см. в разделе «Работа со стеком» на стр. 19 по адресу.
- *Строковые адреса* - Строковые инструкции генерируют последовательные адреса, используя регистры rDI и rSI, как описано в разделе «Неявное использование GPR» на странице 30.

В 64-битном режиме, без переопределения размера адреса, размер вычислений эффективного адреса составляет 64 бита. Вычисление эффективного адреса использует 64-битные базовый и индексный регистры и расширяет смещения по знаку до 64 бит. Из-за плоского адресного пространства в 64-битном режиме виртуальные адреса равны эффективным адресам. (Исключение из этого общего правила см. в разделе «FS и GS как база для вычисления адреса» на стр. 17).

#### 2.2.3.1 Нулевое расширение 16- и 32-битных адресов в длинном режиме

В длинном режиме все вычисления 16- и 32-битных адресов расширяются до нуля для формирования 64-битных адресов. Вычисления адреса сначала усекаются до эффективного размера адреса текущего режима (64-битный режим или режим совместимости), что отменяется любым префиксом размера адреса. Затем результат обнуляется и расширяется до полной 64-битной ширины адреса. Из-за этого 16- и 32-битные приложения, работающие в режиме совместимости, могут получить доступ только к младшим 4 ГБ виртуального адресного пространства длинного режима. Аналогично, 32-битный адрес, сгенерированный в 64-битном режиме, может получить доступ только к младшим 4 ГБ виртуального адресного пространства длинного режима.

#### 2.2.3.1 Displacements and immediates 

В общем случае максимальный размер смещений адреса и непосредственных операндов составляет 32 бита. Они могут иметь размер 8, 16 или 32 бита, в зависимости от инструкции или, для смещений, эффективного размера адреса. В 64-битном режиме смещения при использовании расширяются по знаку до 64 бит, но их фактический размер (для представления значений) остается максимум 32 бита. То же самое справедливо и для непосредственных адресов в 64-битном режиме, когда размер операнда равен 64 битам. Тем не менее, в 64-битном режиме некоторые 64-битные смещения и непосредственные формы инструкции MOV.

#### 2.2.3.3 FS и GS как база для вычисления адреса

В 64-битном режиме сегментные базовые регистры FS и GS (в отличие от сегментных базовых регистров DS, ES и SS) могут использоваться в качестве ненулевых базовых регистров сегмента данных для вычисления адреса, как описано в разделе «Сегментированная виртуальная память» в томе 2. 64-битный режим предполагает, что все остальные сегментные регистры данных (DS, ES и SS) имеют базовый адрес, равный 0.

### 2.2.4 Адресно-размерный префикс

Размер адреса инструкции по умолчанию определяется битом default-size (D) и битом long-mode (L) в дескрипторе текущего кодового сегмента (подробнее см. раздел «Сегментированная виртуальная память» в томе 2). Прикладное программное обеспечение может переопределить размер адреса по умолчанию в любом режиме работы, используя префиксный байт инструкции размера адреса 67h. Префикс размера адреса позволяет смешивать 32-битные и 64-битные адреса по каждой инструкции.

В таблице 2-1 на странице 18 показаны эффекты от использования префикса размера адреса во всех режимах работы. В 64-битном режиме размер адреса по умолчанию составляет 64 бита. Размер адреса может быть изменен на 32 бита. 16-битные адреса в 64-битном режиме не поддерживаются. В режимах совместимости и устаревших версий префикс размера адреса работает так же, как и в устаревшей архитектуре x86.

<img src="Pasted image 20250629161442.png">

### 2.2.5 RIP - относительная адресация

RIP-относительная адресация, то есть адресация относительно 64-битного указателя инструкций (также называемого программным счетчиком), доступна в 64-битном режиме. Эффективный адрес формируется путем прибавления смещения к 64-битному RIP следующей инструкции.

В унаследованной архитектуре x86 адресация относительно указателя инструкции (IP или EIP) доступна только в инструкциях с передачей управления. В 64-разрядном режиме любая инструкция, использующая адресацию ModRM (см. «ModRM и SIB-байты» в томе 3), может использовать RIP-относительную адресацию. Эта возможность особенно полезна для адресации данных в позиционно-независимом коде и для кода, обращающегося к глобальным данным.

Программы обычно содержат много ссылок на данные, особенно на глобальные данные, которые не основаны на регистрах. Чтобы загрузить такую программу, загрузчик обычно выбирает место для программы в памяти, а затем корректирует
ссылки программы на глобальные данные в зависимости от места загрузки. RIP-относительная адресация данных делает эту настройку ненужной.

#### 2.2.5.1 Диапазон RIP-относительной адресации

Без RIP-относительной адресации инструкции, закодированные с помощью байта ModRM, обращаются к памяти относительно к нулю. При RIP-относительной адресации инструкции с байтом ModRM могут обращаться к памяти относительно 64-битного RIP, используя знаковое 32-битное смещение. Это обеспечивает диапазон смещения 2 Гбайт относительно RIP.

#### 2.2.5.2 Влияние размера префикса адреса на относительную адресацию RIP

Относительная адресация RIP включается 64-битным режимом, а не 64-битным размером адреса. И наоборот, использование префикса размера адреса не отключает относительную адресацию RIP. Эффект префикса размера адреса заключается в том, что усекает и расширяет вычисленный эффективный адрес до 32 бит, как и любой другой режим адресации.

#### 2.2.5.3 Кодирование

Подробнее о кодировании инструкций для RIP-относительной адресации см. в разделе «Кодирование для RIP-относительной адресации» в томе 3.

## 2.3 Указатели

Указатели - это переменные, содержащие адреса, а не данные. Они используются инструкциями для ссылки на память. Инструкции обращаются к данным с помощью ближних и дальних указателей. Указатели стека определяют местоположение текущего стека.

### 2.3.1 Ближний и дальний указатели

Ближние указатели содержат только эффективный адрес, который используется как смещение в текущий сегмент. Дальние указатели содержат как эффективный адрес, так и селектор сегмента, указывающий один из нескольких сегментов. На рисунке 2-8 показаны два типа указателей.

<img src="Pasted image 20250629173033.png">

В 64-битном режиме архитектура AMD64 поддерживает только модель плоской памяти, в которой есть только один сегмент данных, поэтому эффективный адрес используется как виртуальный (линейный) адрес и дальние указатели не нужны. В режиме совместимости и в унаследованном защищенном режиме архитектура AMD64 поддерживает несколько сегментов памяти, поэтому эффективные адреса можно комбинировать с селекторами сегментов для формирования дальних указателей, а термины *логический адрес* (селектор сегмента и эффективный адрес) и *дальний указатель* являются синонимами. Ближние указатели также могут использоваться в режиме совместимости и Legacy режиме.

## 2.4 Операции со стеком

Стек процедур (также известный как «стек программ») - это часть сегмента стека в памяти, которая используется для связи процедур. В программных соглашениях стеки обычно определяются с помощью рамки стека, которая состоит из двух регистров - базового указателя рамки стека (rBP) и указателя стека (rSP), как показано на Рисунке 2-9 на странице 20. Эти указатели стека могут быть как ближними, так и дальними указателями.

Регистр сегмента стека (SS) указывает на базовый адрес текущего сегмента стека. Указатели стека содержат смещения от базового адреса текущего сегмента стека. Все инструкции, которые обращаются к памяти с помощью регистров rBP или rSP, заставляют процессор обращаться к текущему сегменту стека.

<img src="Pasted image 20250629173511.png">

В типичных API базовый указатель стекового кадра и указатель стека указывают на одно и то же место перед вызовом процедуры (вершина стека предыдущего стекового кадра). После того, как данные помещаются в стек процедуры, базовый указатель кадра стека остается на прежнем месте, а указатель стека перемещается вниз, чтобы адрес ниже помещенных данных, где он становится новой вершиной стека.

В унаследованных и совместимых режимах размер указателя стека по умолчанию составляет 16 бит (SP) или 32 бита (ESP), зависимости от бита default-size (B) в дескрипторе сегмента стека, и несколько стеков могут поддерживаться в отдельных сегментах стека. В 64-битном режиме указатели стека всегда имеют ширину 64 бита (RSP).

Дальнейшие подробности прикладного программирования о механизме стека процедур описаны в разделе «Передачи управления» на странице 80. Подробности системного программирования о сегментах стека описаны в «Сегментированная виртуальная память» в томе 2.

Теневой стек - это отдельный защищенный стек, который концептуально параллелен стеку процедур и используется только функцией теневого стека. При включении системным программным обеспечением функция теневого стека обеспечивает прозрачную для прикладного программного обеспечения защиту от класса компьютерных эксплойтов, известных как «программирование, ориентированное на возврат». Подробности системного программирования функции теневого стека описаны в разделе «Теневые стеки» в томе 2.

## 2.5 Указатель на инструкцию

Указатель инструкции используется совместно с регистром code-segment (CS) для поиска следующей. инструкции в памяти. Регистр указателя на инструкцию содержит смещение (offset)-от базового адреса текущего сегмента CS, или от адреса 0 в 64-битном режиме до следующей команды, которая будет выполнена. Указатель увеличивается последовательно, за исключением указаний на ответвление, как описано в. "Передачи управления" на странице 80.

В устаревшем и совместимом режимах указатель инструкций является 16-битным (IP) или 32-битным регистром (EIP). В 64-разрядном режиме указатель инструкций расширяется до 64-разрядного (RIP) регистра для поддержки 64-разрядных смещений. Акроним с учетом регистра rIP используется для обозначения любого из этих трех размеров указателей инструкций в зависимости от контекста программного обеспечения. 

Рисунок 2-10 на странице 21 показывает взаимосвязь между RIP, EIP и IP. 64-разрядный RIP может использоваться для адресации относительной RIP, как описано в разделе "Относительная адресация RIP" на странице 18. 

<img src="Pasted image 20250629174928.png">

Содержимое RIP не читается напрямую программным обеспечением. Однако, RIP помещается в стек по инструкции вызова.

Модель памяти, описанная в этой главе, используется всеми средами программирования, составляющими архитектуру AMD64. Следующие четыре главы этого тома описывают среды программирования приложений, которые включают:
- Универсальное программирование (глава З на странице 23).
- Потоковые расширения SIMD, используемые в средствах массовой информации и научных программах (глава 4 на странице 111).
- 64-bit media programming (глава 5 на странице 239).
- Программирование с плавающей точкой x87 (глава 6 на странице 285).