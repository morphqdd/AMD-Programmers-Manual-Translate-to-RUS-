# 1. Обзор архитектуры AMD64
## 1.1 Введение

Архитектура AMD64 - это простое, но мощное 64-битное, обратно совместимое расширение стандартной (устаревшей) архитектуры x86. Она добавляет 64-битную адресацию и расширяет регистровые ресурсы для поддержки более высокой производительности перекомпилированных 64-битных программ, в то же время поддерживая старые 16- и 32-битные приложения и операционные системы без модификации или перекомпиляции. Это архитектурная основа, на которой новые процессоры могут обеспечить бесперебойную высокопроизводительную поддержку как огромного количества существующего программного обеспечения, так и 64-битного программного обеспечения, необходимого для более высокопроизводительных приложений.

Потребность в 64-разрядной архитектуре x86 обусловлена приложениями, которые обращаются к большим объемам виртуальной и физической памяти, например, высокопроизводительными серверами, системами управления базами данных и инструментами САПР. Эти приложения выигрывают как от 64-битных адресов, так и от увеличенного количества регистров. Небольшое количество регистров, доступное в устаревшей архитектуре x86, ограничивает производительность приложений, требующих больших вычислений. Увеличение числа регистров позволяет повысить производительность многих таких приложений.
### 1.1.1 Возможности AMD64
Архитектура AMD64 включает в себя следующие возможности:
- Расширения регистров (см. Рисунок 1-1 на стр. 2):
	- 8 дополнительных регистров общего назначения (GPR).
	- Все 16 GPR имеют ширину 64 бита.
	- 8 дополнительных регистров YMM/XMM.
	- Единая байт-регистровая адресация для всех GPR.
	- Доступ к расширенным регистрам осуществляется с помощью префикса инструкции (REX).
- Длинный режим (см. таблицу 1-1 на странице 2):
	- До 64 бит виртуального адреса.
	- 64-битный указатель инструкций (RIP).
	- Режим адресации данных по указателю инструкций.
	- Плоское адресное пространство.


<img src="./Pasted image 20250627165307.png">
<img src="./Pasted image 20250627165404.png" >

### 1.1.2 Регистры
В таблице 1-2 приведено сравнение ресурсов регистров и стека, доступных прикладному программному обеспечению, в зависимости от режима работы. В левом ряду столбцов показаны ресурсы устаревшей архитектуры x86, которые доступны в режимах устаревшей архитектуры AMD64 и совместимости. В правом ряду столбцов показаны сопоставимые ресурсы в 64-битном режиме. Серым цветом выделены различия между режимами. Эти различия в регистрах (без учета разницы в ширине стека) представляют собой расширения регистров, показанные на Рисунок 1-1.

<img src="Pasted image 20250627165622.png" >

---

**Примечание:**
1. Записи, затененные серым цветом, указывают на различия между режимами. Эти различия (за исключением разницы в ширине стека) связаны с расширениями регистров архитектуры AMD64.
2. GPRs перечислены с использованием их полных имен. В унаследованном режиме и режиме совместимости также доступны 16- и 8-битные отображения регистров. В 64-битном режиме доступны 32-битные, 16-битные и 8-битные отображения. См. Раздел 3.1. «Регистры» на стр. 23.
3. Регистры XMM перекрывают младшее восьмое слово регистров YMM. См. раздел 4.2. «Регистры» на странице 113.
4. Регистры MMX0-MMX7 отображаются на физические регистры FPR0-FPR7, как показано на рисунке 1-1. Регистры стека x87, ST(0)-ST(7), являются логическими отображениями физических регистров FPR0-FPR7.

---
Как видно из таблицы 1-2, устаревшая архитектура x86 (в архитектуре AMD64 она называется legacy mode) поддерживает восемь GPR. Однако в действительности общее использование по крайней мере четырех регистров (EBP, ESI, EDI и ESP) скомпрометировано, поскольку они служат специальным целям при выполнении многих инструкций. Добавление в архитектуру AMD64 восьми регистров GPR и увеличение ширины этих регистров с 32 бит до 64 бит позволяет компиляторам существенно повысить производительность программ. Компиляторы имеют большую гибкость в использовании регистров для хранения переменных. Кроме того, могут минимизировать трафик памяти и тем самым увеличить производительность за счет локализации работы в GPR.

### 1.1.3 Набор инструкций
Архитектура AMD64 поддерживает полный набор традиционных инструкций x86 с дополнительными инструкциями для поддержки длинного режима (см. таблицу 1-1 на стр. 2 для краткого описания режимов работы). Инструкции прикладного программирования разделены на четыре подмножества:

* *Инструкции общего назначения* (GPI) - это основные целочисленные инструкции x86, используемые практически во всех программах. Большинство этих инструкций загружают, сохраняют или оперируют данными, расположенными в регистрах общего назначения (GPRs) или в памяти. Некоторые из инструкций изменяют последовательный ход программы путем ветвления в другие места программы.

* Инструкции потоковых SIMD-расширений (SSE) - эти инструкции загружают, сохраняют или работают с данными, расположенными преимущественно в регистрах YMM/XMM. 128-битные мультимедийные инструкции работают с нижней половиной регистров YMM. Инструкции SSE выполняют целочисленные операции и операции с плавающей точкой над векторными (упакованными) и скалярными типами данных. Поскольку векторные инструкции могут независимо и одновременно выполнять одну операцию над несколькими наборами данных, они называются инструкциями с одной инструкцией и несколькими данными (SIMD). Они полезны для высокопроизводительных мультимедийных и научных приложений, оперирующих блоками данных.

* Инструкции расширения мультимедиа - включают инструкции технологии MMX™ и технологии AMD 3DNow!™. Эти инструкции загружают, сохраняют или оперируют данными, расположенными преимущественно в 64-битных регистрах MMX, которые отображаются на 80-битные регистры x87 с плавающей точкой. Как и инструкции SSE, они выполняют целочисленные операции и операции с плавающей точкой над векторными (упакованными) и скалярными данными типа. Эти инструкции полезны в мультимедийных приложениях, не требующих высокой точности. Инструкции Multimedia Extension Instructions используют насыщающие математические операции, которые не генерируют исключений операций. AMD отказалась от использования инструкций 3DNow!, которые были вытеснены их более эффективными аналогами SSE. Соответствующие рекомендации приведены в Главе 5, «Программирование 64-разрядных носителей» на странице 239, и в Руководстве программиста AMD64 Том 4: 64-разрядные носители и инструкции x87 с плавающей точкой.

* Инструкции x87 с плавающей точкой - это инструкции с плавающей точкой, используемые в устаревших приложениях x87. Они загружают, сохраняют или оперируют данными, расположенными в 80-битных регистрах x87.

Некоторые из этих инструкций прикладного программирования объединяют два или более подмножества. Например, есть инструкции, которые перемещают данные между регистрами общего назначения и регистрами YMM/XMM или MMX, а многие инструкции целочисленных векторов (упакованных) могут работать с регистрами YMM/XMM или MMX, хотя и не одновременно. Если инструкции пересекают два или более подмножеств, их описания повторяются во всех подмножествах, к которым они относятся.

### 1.1.4 Мультимедийные инструкции

Мультимедийные приложения, такие как обработка изображений, синтез музыки, распознавание речи, полноэкранное видео и рендеринг 3D-графики, имеют общие характеристики:

- Они обрабатывают большие объемы данных.
- Они часто выполняют одну и ту же последовательность операций над данными.
- Данные часто представляются в виде небольших величин, например 8 бит для значений пикселей, 16 бит для образцов звука и 32 бита для координат объектов в формате с плавающей точкой.

Инструкции SSE и MMX предназначены для ускорения работы этих приложений. Эти инструкции используют форму векторной (или пакетной) параллельной обработки, известную как обработка с одной инструкцией и несколькими данными (SIMD). Эта векторная технология имеет следующие характеристики:

- Один регистр может содержать несколько независимых частей данных. Например, один регистр YMM может содержать 32 8-битных целочисленных элемента данных или восемь 32-битных элементов данных с плавающей точкой одинарной точности.
- Векторные инструкции могут работать со всеми элементами данных в регистре, независимо и одновременно. Например, инструкция PADDB, работающая с байтовыми элементами двух операндов вектора в 128-битных регистрах XMM, выполняет 16 одновременных сложений и возвращает 16 независимых результатов за одну операцию.

Инструкции SSE и MMX делают еще один шаг вперед в развитии векторной технологии SIMD, включая специальные инструкции, которые выполняют операции, часто встречающиеся в мультимедийных приложениях. Например, графическое приложение, которое складывает значения яркости двух пикселей, должно предотвратить сворачивание операции сложения до маленького значения, если результат переполняет регистр назначения, поскольку результат переполнения может привести к неожиданным эффектам, таким как темный пиксель там, где ожидался светлый. Эти инструкции включают в себя насыщающие арифметические инструкции, упрощающие этот тип операций. Результат, который в противном случае обернулся бы вокруг из-за переполнения или недополнения, вместо этого принудительно насыщается по наибольшему или наименьшему значению, которое может быть представлено в регистре назначения.

### 1.1.5 Инструкции с плавающей точкой

Архитектура AMD64 предоставляет три подмножества инструкций с плавающей точкой, использующих три различных набора регистров:
* Инструкции SSE поддерживают 32-битные операции с плавающей точкой одинарной точности и 64-битные операции с плавающей точкой двойной точности, в дополнение к целочисленным операциям. Операции как с векторными, так и со скалярными данными поддерживаются по адресу, при этом имеется специальный механизм регистрации исключений операций с плавающей точкой. Эти операции с плавающей точкой соответствуют стандарту IEEE-754.
* Инструкции MMX поддерживают операции с плавающей точкой одинарной точности. Поддерживаются операции как с векторными данными, так и со скалярными данными, но эти инструкции не поддерживают отчет об исключениях с плавающей точкой.
* Инструкции x87 с плавающей точкой поддерживают операции с плавающей точкой одинарной точности, двойной точности и 80-битные операции с расширенной точностью. Поддерживаются только скалярные данные, а также специальный механизм регистрации исключений для операций с плавающей точкой. Инструкции x87 для операций с плавающей точкой содержат специальные инструкции для выполнения тригонометрических и логарифмических трансцендентных операций. Операции с плавающей точкой одинарной точности и двойной точности соответствуют стандарту IEEE-754.

Максимальная производительность операций с плавающей точкой достигается при использовании 256-битных векторных инструкций. Одна из этих векторных инструкций может поддерживать до восьми операций с одинарной точностью (или четырех с двойной точностью) параллельно. Всего 16 256-битных регистров YMM, доступных в 64-битном режиме, ускоряют работу приложений, предоставляя больше регистров для хранения промежуточных результатов, что уменьшает необходимость хранить эти результаты в памяти. Меньшее количество загрузок и сохранений обеспечивает более высокую производительность.

## 1.2 Режимы работы

В таблице 1-1 на странице 2 приведены режимы работы, поддерживаемые архитектурой AMD64. В большинстве случаев адреса и размеры операндов по умолчанию могут быть отменены с помощью префиксов инструкций. Расширения регистров, показанные во втором справа столбце таблицы 1-1, соответствуют тем, которые проиллюстрированы на Рисунок 1-1 на странице 2.

### 1.2.1 Длинный режим

Длинный режим - это расширение унаследованного защищенного режима. Длинный режим состоит из двух подрежимов: 64-битного режима и режима совместимости. 64-битный режим поддерживает все возможности и расширения регистров архитектуры AMD64. Режим совместимости поддерживает двоичную совместимость с существующими 16-битными и 32-битными приложениями. Длинный режим не поддерживает унаследованный реальный режим или унаследованный виртуальный режим 8086, а также не поддерживает аппаратное переключение задач.

В этом документе ссылки на длинный режим относятся как к 64-битному режиму, так и к режиму совместимости. Если функция специфична для одного из этих подрежимов, то вместо названия long mode используется название конкретного подрежима.

### 1.2.2 64-битный режим

64-битный режим - подрежим длинного режима - поддерживает весь спектр возможностей 64-битной виртуальной адресации и расширения регистров. Этот режим включается операционной системой на основе отдельных кодовых сегментов. Поскольку 64-битный режим поддерживает 64-битное виртуальное адресное пространство, он требует 64-битной операционной системы и цепочки инструментов. Существующие двоичные файлы приложений могут работать без перекомпиляции в режиме совместимости под управлением операционной системы, работающей в 64-битном режиме, или же приложения могут быть перекомпилированы для работы в 64-битном режиме.

Особенности адресации включают 64-битный указатель инструкций (RIP) и режим RIP-относительной адресации данных. В этом режиме современные операционные системы поддерживают только плоское адресное пространство, с единым пространством кода, данных и стека.

**Расширения регистров.** 64-битный режим реализует расширения регистров с помощью группы префиксов инструкций, называемых префиксами REX. Эти расширения добавляют восемь GPR (R8-R15), расширяют все GPR до 64 бит, и добавляют восемь регистров YMM/XMM (YMM/XMM8-15).

Префиксы инструкций REX также предоставляют возможность работы с байтными регистрами, благодаря чему младший байт любого из шестнадцати GPR доступен для байтовых операций. В результате получается унифицированный набор регистров: байт (byte), слово (word), двойное слово (doubleword) и четверное слово (quadword), который лучше подходит для распределения регистров компилятором.

**64-битные адреса и операнды.** В 64-битном режиме размер виртуального адреса по умолчанию составляет 64 бита (в реализации может быть меньше). Размер операнда по умолчанию для большинства инструкций равен 32 битам. Для большинства инструкций эти значения по умолчанию могут быть отменены для каждой инструкции с помощью префиксов. Префиксы REX определяют 64-битный размер операнда и расширения регистров.

**RIP-относительная адресация данных.** 64-битный режим поддерживает адресацию данных относительно 64-битного указателя инструкций (RIP). Унаследованная архитектура x86 поддерживает IP-относительную адресацию только в инструкциях передачи управления. Относительная RIP-адресация повышает эффективность позиционно-независимого кода и кода, обращающегося к глобальным данным.

**Опкоды.** Несколько операционных кодов инструкций и префиксных байтов переопределены, чтобы обеспечить расширение регистров и 64-битную адресацию. Эти различия описаны в Приложении B «Инструкции общего назначения в 64-битном режиме» и Приложении C «Различия между длинным режимом и режимом Legacy» в томе 3.

### 1.2.3 Режим совместимости

Режим совместимости - второй подрежим длинного режима - позволяет 64-битным операционным системам запускать существующие 16- и 32-битные приложения x86. Эти устаревшие приложения запускаются в режиме совместимости без перекомпиляции.

Приложения, работающие в режиме совместимости, используют 32- или 16-разрядную адресацию и могут получить доступ к первым 4 ГБ виртуального адресного пространства. Префиксы устаревших инструкций x86 позволяют переключаться между 16- и 32-разрядными адресами и размерами операндов.

Как и в 64-битном режиме, режим совместимости включается операционной системой на основе отдельных кодовых сегментов. Однако, в отличие от 64-битного режима, сегментация x86 функционирует так же, как и в унаследованной архитектуре x86, используя 16- или 32-битную семантику защищенного режима. С точки зрения приложений, режим совместимости выглядит как среда защищенного режима старой архитектуры x86. Однако с точки зрения операционной системы трансляция адресов, обработка прерываний и исключений, а также системные структуры данных используют 64-битные механизмы long-mode.

### 1.2.4 Legacy режим

Режим Legacy сохраняет бинарную совместимость не только с существующими 16- и 32-битными приложениями, но и с существующими 16- и 32-битными операционными системами. Режим Legacy состоит из следующих трех подрежимов:

* ***Защищенный режим*** - защищенный режим поддерживает 16- и 32-разрядные программы с сегментацией памяти, опциональной подкачкой и проверкой привилегий. Программы, работающие в защищенном режиме, могут получить доступ к 4 ГБ памяти по адресу.
* ***Режим Virtual-8086*** - Virtual-8086 поддерживает 16-разрядные программы реального режима, выполняемые как задачи в защищенном режиме. В нем используется простая форма сегментации памяти, опциональная подкачка и ограниченная проверка защиты. Программы, работающие в режиме virtual-8086, могут получить доступ к 1 МБ памяти.
* ***Реальный режим*** - Реальный режим поддерживает 16-битные программы, использующие простую сегментацию памяти на основе регистров. Он не поддерживает подкачку и проверку защиты. Программы, работающие в реальном режиме, могут получить доступ к памяти объемом до 1 МБ.

Режим Legacy совместим с существующими 32-разрядными процессорами, реализующими архитектуру x86. Процессоры, реализующие архитектуру AMD64, загружаются в унаследованном реальном режиме, как и процессоры, которые реализуют унаследованную архитектуру x86.

# 2. Модель памяти

## 2.1 Организация памяти

### 2.1.1 Виртуальная память

Виртуальная память состоит из всего адресного пространства, доступного программам. Это большое линейно-адресное пространство, которое преобразуется комбинацией аппаратных средств и программного обеспечения операционной системы в меньшее физическое адресное пространство, часть которого находится в памяти, а часть - на диске или другом внешнем носителе.

На рисунке 2-1 на странице 10 показано, как обрабатывается пространство виртуальной памяти в двух подрежимах длинного режима:

- *64-битный режим* - в этом режиме используется модель плоской сегментации виртуальной памяти. 64-битное пространство виртуальной памяти рассматривается как единое, плоское (несегментированное) адресное пространство. Адреса программы обращаются к местам, которые могут находиться в любом месте линейного 64-битного адресного пространства. Операционная система может использовать отдельные селекторы для сегментов кода, стека и данных в целях защиты памяти, но базовый адрес всех этих сегментов всегда равен 0. (Исключение из этого общего правила см. в разделе «FS и GS как база для вычисления адреса» на странице 17).

- *Режим совместимости* - в этом режиме используется защищенная многосегментная модель виртуальной памяти, как и в унаследованном защищенном режиме. 32-битное пространство виртуальной памяти рассматривается как сегментированный набор адресных пространств для сегментов кода, стека и данных, каждый из которых имеет свой базовый адрес и параметры защиты. Сегментированное пространство задается путем добавления к адресу селектора сегмента.

<img src="./Pasted image 20250629145705.png" >

Операционные системы используют сегментированную память как метод изоляции программ от данных, которые они используют, в попытке повысить надежность систем, в которых одновременно работают несколько программ. Однако большинство современных операционных систем не используют возможности сегментации, доступные в устаревшей архитектуре x86. Вместо этого эти операционные системы выполняют функции сегментации полностью программно. По этой причине архитектура AMD64 в 64-битном режиме обходится без большинства унаследованных функций сегментации. Это позволяет более просто кодировать 64-битные операционные системы и поддерживает более эффективное управление многозадачными средами, чем это возможно в устаревшей архитектуре x86.

### 2.1.2 Сегментные регистры

Сегментные регистры содержат селекторы, используемые для доступа к сегментам памяти. На рисунке 2-2 на странице 11 показана видимая приложению часть сегментных регистров. В унаследованном режиме и режиме совместимости все сегментные регистры доступны для программного обеспечения. В 64-битном режиме процессор распознает только сегменты CS, FS и GS, и программы могут использовать базовые регистры сегментов FS и GS в качестве базовых регистров для вычисления адреса, как описано в разделе «FS и GS как база для вычисления адреса» на странице 17. Для обращений к сегментам DS, ES или SS в 64-битном режиме процессор предполагает, что база каждого из этих сегментов равна нулю, не проверяются ни границы сегментов, ни их атрибуты, и процессор просто проверяет, что все такие адреса имеют каноническую форму, как описано в разделе «64-битные канонические адреса» на странице 15.

<img src="Pasted image 20250629150519.png" >

### 2.1.3 Физическая память

Физическая память - это установленная память (за исключением кэш-памяти) в конкретной компьютерной системе, доступ к которой возможен через шинный интерфейс процессора. Максимальный размер пространства физической памяти определяется с помощью адресных битов на шинном интерфейсе. В системе виртуальной памяти большое виртуальное адресное пространство (также называемое линейным адресным пространством) преобразуется в меньшее физическое адресное пространство с помощью комбинации аппаратных и программных средств сегментации и подкачки.

Сегментация показана на рисунке 2-1 на странице 10. Пейджинг - это механизм преобразования линейных (виртуальных) адресов в блоки фиксированного размера, называемые страницами, которые операционная система может перемещать по мере необходимости между памятью и внешними носителями (обычно дисками). Архитектура AMD64 поддерживает расширенную версию устаревшего механизма подкачки x86, которая способна преобразовывать полное 64-битное виртуальное адресное пространство в физическое адресное пространство, поддерживаемое конкретной реализацией.

### 2.1.4 Управление памятью

Стратегии управления памятью переводят адреса, генерируемые программами, в адреса в физической памяти с помощью сегментации и/или подкачки. Управление памятью не видно прикладным программам. Им занимаются операционная система и аппаратное обеспечение процессора. Ниже приводится очень краткий обзор этих функций. Более подробная информация приведена в разделе «Инструкции системного управления» в томе 2.

#### 2.1.4.1 Управление памятью в длинном режиме

На рисунке 2-3 показан поток, сверху вниз, функций управления памятью, выполняемых в двух подрежимах длинного режима.

<img src="Pasted image 20250629151331.png" >

В 64-битном режиме программы генерируют виртуальные (линейные) адреса, размер которых может достигать 64 бит. Виртуальные адреса передаются функции подкачки в длинном режиме, которая генерирует физические адреса, размер которых может достигать 52 бит. (Конкретные реализации архитектуры могут поддерживать меньшие размеры виртуальных и физических адресов).

В режиме совместимости устаревшие 16- и 32-битные приложения работают с использованием семантики сегментации в защищенном режиме x86. 16- или 32-битные эффективные адреса, генерируемые программами, объединяются с их сегментами для получения 32-битных виртуальных (линейных) адресов, которые расширяются до нуля и составляют максимум 64 бита. Последующая подкачка - это та же функция подкачки в длинном режиме, которая используется в 64-битном режиме. Она преобразует виртуальные адреса в физические. Комбинация селектора сегмента и эффективного адреса также называется *логическим адресом* или *дальним указателем*. *Виртуальный адрес* также называется линейным адресом.

#### 2.1.4.2 Управление памяти в устаревшем режиме (Legacy mode)

На рисунке 2-4 на странице 13 показаны функции управления памятью, выполняемые в трех подрежимах устаревшего режима.

<img src="Pasted image 20250629152126.png" >

В зависимости от подрежима функции управления памятью различаются следующим образом:
- *Защищенный режим* - защищенный режим поддерживает 16- и 32-битные программы с табличной сегментацией памяти, подкачкой и проверкой привилегий. Функция сегментации принимает 32-битные эффективные адреса и 16-битные селекторы сегментов и выдает 32-битные линейные адреса в один из 16K сегментов памяти, каждый из которых может быть размером до 4 ГБ. Подкачка необязательна. 32-битные физические адреса либо создаются функцией подкачки, либо линейные адреса используются без модификации в качестве физических адресов.
- *Режим Virtual-8086* - режим Virtual-8086 поддерживает 16-разрядные программы, выполняемые как задачи в защищенном режиме. 20-битные линейные адреса формируются так же, как и в реальном режиме, но по желанию могут быть транслированы через функцию подкачки для формирования 32-битных физических адресов, обеспечивающих доступ к памяти объемом до 4 ГБ.
- *Реальный режим* - данный режим поддерживает 16-битные программы, использующие регистровую сегментацию со сдвигом и добавлением, но не поддерживает подкачку. Шестнадцатибитные эффективные адреса расширяются до нуля и добавляются к 16-битному адресу сегмента-базы, который сдвигается на четыре бита влево, в результате чего получается 20-битный линейный адрес. Линейный адрес расширяется до 32-битного физического адреса, по которому можно получить доступ к памяти объемом до 1 МБ.

## 2.2 Адресация памяти

### 2.2.1 Очередь байт

Инструкции и данные хранятся в памяти в *little-endian* порядке байт. Младший порядок помещает наименее значимый байт инструкции или элемента данных по младшему адресу памяти, а наиболее значимый байт - по старшему адресу памяти.

На рисунке 2-5 показано обобщение little-endian памяти и регистровых образов типа данных quadword. Младший байт находится по младшему адресу в памяти и по крайнему правому в образе регистра.

<img src="Pasted image 20250629153001.png">

На рисунке 2-6 на странице 15 показан образ памяти для 10-байтовой инструкции. Инструкции относятся к байтовым типам данных. Они считываются из памяти по одному байту за раз, начиная с наименьшего значащего байта (младшего адреса). Например, следующая инструкция задает 64-битную инструкцию MOV RAX, 1122334455667788, состоящую из следующих десяти байт:

```
48 B8 8877665544332211
```

48 - префикс инструкции REX, задающий 64-битный размер операнда, B8 - опкод, который вместе с префиксом REX определяет 64-битный регистр назначения RAX, а 8877665544332211 - 8-байтовое непосредственное значение для перемещения, где 88 представляет восьмой (наименее значащий) байт, а 11 - первый (наиболее значащий) байт. В памяти байт префикса REX (48) будет храниться по младшему адресу, а первый непосредственный байт (11) - по старшему адресу инструкции

<img src="Pasted image 20250629153308.png" >

### 2.2.2 Каноничные 64-битные адреса

Длинный режим определяет 64 бита виртуального адреса, но реализации архитектуры AMD64 могут поддерживать меньшее количество битов виртуального адреса. Хотя реализации могут не использовать все 64 бита виртуального адреса, они проверяют биты с 63 по самый значимый реализованный бит, чтобы убедиться, что в этих битах все нули или все единицы. Адрес, удовлетворяющий этому свойству, считается *адресом в канонической форме*. Если ссылка на виртуальную память не имеет канонической формы, реализация вызывает исключение общей защиты или ошибку стека.

### 2.2.3 Эффективные адреса

Программы предоставляют эффективные адреса аппаратным средствам до сегментации и трансляции страниц. Эффективные адреса в длинном режиме имеют максимальную ширину 64 бита, как показано на рисунке 2-3 на странице 12.
Программы, работающие в режиме совместимости, генерируют (по умолчанию) 32-битные эффективные адреса, которые аппаратное обеспечение расширяет до 64 бит. Эффективные адреса в режиме Legacy без переопределения размера адреса имеют ширину 32 или 16 бит, как показано на рисунке 2-4 на странице 13. Эти размеры можно изменить с помощью префикса инструкции addresssize, как описано в разделе «Префиксы инструкций» на странице 76.

Существует пять методов генерации эффективных адресов, в зависимости от конкретной инструкции:
* *Абсолютные адреса* - эти адреса задаются как смещения (или сдвиги) от базового адреса сегмента данных. Они указывают непосредственно на ячейку памяти в сегменте данных.
* *Относительные адреса инструкций* - эти адреса задаются как смещения (или сдвиги) от текущего указателя инструкций (IP), также называемого программным счетчиком (PC). Они генерируются инструкциями передачи управления. Смещение в кодировке инструкции или считанное из памяти служит смещением от адреса, следующего за передачей. Подробности о RIP-относительной адресации в 64-битном режиме см. в разделе «RIP-относительная адресация» на стр. 18.
* *Индексированные регистровые адреса* - эти адреса вычисляются по базовому адресу, содержащемуся в регистре общего назначения, указанному в инструкции (base). Различные кодировки позволяют смещение от этой базы с помощью знакового смещения или суммы смещения и масштабированного значения индекса. В кодировках инструкций может использоваться до десяти байт - байт ModRM, дополнительный байт SIB (scale, index, base) и смещение переменной длины - для указания значений, которые будут использоваться при вычислении эффективного адреса. Значения базы и индекса содержатся в регистрах общего назначения, указанных байтом SIB. Значения масштаба и смещения указываются непосредственно в кодировке инструкции. На рисунке 2-7 показаны компоненты вычисления адреса. Полученный эффективный адрес добавляется к базовому адресу сегмента данных для формирования линейного адреса, как описано в разделе «Сегментированная виртуальная память» в томе 2. В разделе «Форматы инструкций» в томе 3 приводится более подробная информация о задании этой формы адреса.

<img src="Pasted image 20250629155412.png" >

- *Адреса стека* - Инструкции PUSH, POP, CALL, RET, IRET и INT неявно используют указатель стека, который содержит адрес стека процедур. Подробности о размере указателя стека см. в разделе «Работа со стеком» на стр. 19 по адресу.
- *Строковые адреса* - Строковые инструкции генерируют последовательные адреса, используя регистры rDI и rSI, как описано в разделе «Неявное использование GPR» на странице 30.

В 64-битном режиме, без переопределения размера адреса, размер вычислений эффективного адреса составляет 64 бита. Вычисление эффективного адреса использует 64-битные базовый и индексный регистры и расширяет смещения по знаку до 64 бит. Из-за плоского адресного пространства в 64-битном режиме виртуальные адреса равны эффективным адресам. (Исключение из этого общего правила см. в разделе «FS и GS как база для вычисления адреса» на стр. 17).

#### 2.2.3.1 Нулевое расширение 16- и 32-битных адресов в длинном режиме

В длинном режиме все вычисления 16- и 32-битных адресов расширяются до нуля для формирования 64-битных адресов. Вычисления адреса сначала усекаются до эффективного размера адреса текущего режима (64-битный режим или режим совместимости), что отменяется любым префиксом размера адреса. Затем результат обнуляется и расширяется до полной 64-битной ширины адреса. Из-за этого 16- и 32-битные приложения, работающие в режиме совместимости, могут получить доступ только к младшим 4 ГБ виртуального адресного пространства длинного режима. Аналогично, 32-битный адрес, сгенерированный в 64-битном режиме, может получить доступ только к младшим 4 ГБ виртуального адресного пространства длинного режима.

#### 2.2.3.1 Displacements and immediates 

В общем случае максимальный размер смещений адреса и непосредственных операндов составляет 32 бита. Они могут иметь размер 8, 16 или 32 бита, в зависимости от инструкции или, для смещений, эффективного размера адреса. В 64-битном режиме смещения при использовании расширяются по знаку до 64 бит, но их фактический размер (для представления значений) остается максимум 32 бита. То же самое справедливо и для непосредственных адресов в 64-битном режиме, когда размер операнда равен 64 битам. Тем не менее, в 64-битном режиме некоторые 64-битные смещения и непосредственные формы инструкции MOV.

#### 2.2.3.3 FS и GS как база для вычисления адреса

В 64-битном режиме сегментные базовые регистры FS и GS (в отличие от сегментных базовых регистров DS, ES и SS) могут использоваться в качестве ненулевых базовых регистров сегмента данных для вычисления адреса, как описано в разделе «Сегментированная виртуальная память» в томе 2. 64-битный режим предполагает, что все остальные сегментные регистры данных (DS, ES и SS) имеют базовый адрес, равный 0.

### 2.2.4 Адресно-размерный префикс

Размер адреса инструкции по умолчанию определяется битом default-size (D) и битом long-mode (L) в дескрипторе текущего кодового сегмента (подробнее см. раздел «Сегментированная виртуальная память» в томе 2). Прикладное программное обеспечение может переопределить размер адреса по умолчанию в любом режиме работы, используя префиксный байт инструкции размера адреса 67h. Префикс размера адреса позволяет смешивать 32-битные и 64-битные адреса по каждой инструкции.

В таблице 2-1 на странице 18 показаны эффекты от использования префикса размера адреса во всех режимах работы. В 64-битном режиме размер адреса по умолчанию составляет 64 бита. Размер адреса может быть изменен на 32 бита. 16-битные адреса в 64-битном режиме не поддерживаются. В режимах совместимости и устаревших версий префикс размера адреса работает так же, как и в устаревшей архитектуре x86.

<img src="Pasted image 20250629161442.png">

### 2.2.5 RIP - относительная адресация

RIP-относительная адресация, то есть адресация относительно 64-битного указателя инструкций (также называемого программным счетчиком), доступна в 64-битном режиме. Эффективный адрес формируется путем прибавления смещения к 64-битному RIP следующей инструкции.

В унаследованной архитектуре x86 адресация относительно указателя инструкции (IP или EIP) доступна только в инструкциях с передачей управления. В 64-разрядном режиме любая инструкция, использующая адресацию ModRM (см. «ModRM и SIB-байты» в томе 3), может использовать RIP-относительную адресацию. Эта возможность особенно полезна для адресации данных в позиционно-независимом коде и для кода, обращающегося к глобальным данным.

Программы обычно содержат много ссылок на данные, особенно на глобальные данные, которые не основаны на регистрах. Чтобы загрузить такую программу, загрузчик обычно выбирает место для программы в памяти, а затем корректирует
ссылки программы на глобальные данные в зависимости от места загрузки. RIP-относительная адресация данных делает эту настройку ненужной.

#### 2.2.5.1 Диапазон RIP-относительной адресации

Без RIP-относительной адресации инструкции, закодированные с помощью байта ModRM, обращаются к памяти относительно к нулю. При RIP-относительной адресации инструкции с байтом ModRM могут обращаться к памяти относительно 64-битного RIP, используя знаковое 32-битное смещение. Это обеспечивает диапазон смещения 2 Гбайт относительно RIP.

#### 2.2.5.2 Влияние размера префикса адреса на относительную адресацию RIP

Относительная адресация RIP включается 64-битным режимом, а не 64-битным размером адреса. И наоборот, использование префикса размера адреса не отключает относительную адресацию RIP. Эффект префикса размера адреса заключается в том, что усекает и расширяет вычисленный эффективный адрес до 32 бит, как и любой другой режим адресации.

#### 2.2.5.3 Кодирование

Подробнее о кодировании инструкций для RIP-относительной адресации см. в разделе «Кодирование для RIP-относительной адресации» в томе 3.

## 2.3 Указатели

Указатели - это переменные, содержащие адреса, а не данные. Они используются инструкциями для ссылки на память. Инструкции обращаются к данным с помощью ближних и дальних указателей. Указатели стека определяют местоположение текущего стека.

### 2.3.1 Ближний и дальний указатели

Ближние указатели содержат только эффективный адрес, который используется как смещение в текущий сегмент. Дальние указатели содержат как эффективный адрес, так и селектор сегмента, указывающий один из нескольких сегментов. На рисунке 2-8 показаны два типа указателей.

<img src="Pasted image 20250629173033.png">

В 64-битном режиме архитектура AMD64 поддерживает только модель плоской памяти, в которой есть только один сегмент данных, поэтому эффективный адрес используется как виртуальный (линейный) адрес и дальние указатели не нужны. В режиме совместимости и в унаследованном защищенном режиме архитектура AMD64 поддерживает несколько сегментов памяти, поэтому эффективные адреса можно комбинировать с селекторами сегментов для формирования дальних указателей, а термины *логический адрес* (селектор сегмента и эффективный адрес) и *дальний указатель* являются синонимами. Ближние указатели также могут использоваться в режиме совместимости и Legacy режиме.
