# 1. Обзор архитектуры AMD64
## 1.1 Введение

Архитектура AMD64 - это простое, но мощное 64-битное, обратно совместимое расширение стандартной (устаревшей) архитектуры x86. Она добавляет 64-битную адресацию и расширяет регистровые ресурсы для поддержки более высокой производительности перекомпилированных 64-битных программ, в то же время поддерживая старые 16- и 32-битные приложения и операционные системы без модификации или перекомпиляции. Это архитектурная основа, на которой новые процессоры могут обеспечить бесперебойную высокопроизводительную поддержку как огромного количества существующего программного обеспечения, так и 64-битного программного обеспечения, необходимого для более высокопроизводительных приложений.

Потребность в 64-разрядной архитектуре x86 обусловлена приложениями, которые обращаются к большим объемам виртуальной и физической памяти, например, высокопроизводительными серверами, системами управления базами данных и инструментами САПР. Эти приложения выигрывают как от 64-битных адресов, так и от увеличенного количества регистров. Небольшое количество регистров, доступное в устаревшей архитектуре x86, ограничивает производительность приложений, требующих больших вычислений. Увеличение числа регистров позволяет повысить производительность многих таких приложений.
### 1.1.1 Возможности AMD64
Архитектура AMD64 включает в себя следующие возможности:
- Расширения регистров (см. Рисунок 1-1 на стр. 2):
	- 8 дополнительных регистров общего назначения (GPR).
	- Все 16 GPR имеют ширину 64 бита.
	- 8 дополнительных регистров YMM/XMM.
	- Единая байт-регистровая адресация для всех GPR.
	- Доступ к расширенным регистрам осуществляется с помощью префикса инструкции (REX).
- Длинный режим (см. таблицу 1-1 на странице 2):
	- До 64 бит виртуального адреса.
	- 64-битный указатель инструкций (RIP).
	- Режим адресации данных по указателю инструкций.
	- Плоское адресное пространство.


![[./Pasted image 20250627165307.png]]
![[./Pasted image 20250627165404.png]]

### 1.1.2 Регистры
В таблице 1-2 приведено сравнение ресурсов регистров и стека, доступных прикладному программному обеспечению, в зависимости от режима работы. В левом ряду столбцов показаны ресурсы устаревшей архитектуры x86, которые доступны в режимах устаревшей архитектуры AMD64 и совместимости. В правом ряду столбцов показаны сопоставимые ресурсы в 64-битном режиме. Серым цветом выделены различия между режимами. Эти различия в регистрах (без учета разницы в ширине стека) представляют собой расширения регистров, показанные на Рисунок 1-1.![[Pasted image 20250627165622.png]]

---

**Примечание:**
1. Записи, затененные серым цветом, указывают на различия между режимами. Эти различия (за исключением разницы в ширине стека) связаны с расширениями регистров архитектуры AMD64.
2. GPRs перечислены с использованием их полных имен. В унаследованном режиме и режиме совместимости также доступны 16- и 8-битные отображения регистров. В 64-битном режиме доступны 32-битные, 16-битные и 8-битные отображения. См. Раздел 3.1. «Регистры» на стр. 23.
3. Регистры XMM перекрывают младшее восьмое слово регистров YMM. См. раздел 4.2. «Регистры» на странице 113.
4. Регистры MMX0-MMX7 отображаются на физические регистры FPR0-FPR7, как показано на рисунке 1-1. Регистры стека x87, ST(0)-ST(7), являются логическими отображениями физических регистров FPR0-FPR7.

---
Как видно из таблицы 1-2, устаревшая архитектура x86 (в архитектуре AMD64 она называется legacy mode) поддерживает восемь GPR. Однако в действительности общее использование по крайней мере четырех регистров (EBP, ESI, EDI и ESP) скомпрометировано, поскольку они служат специальным целям при выполнении многих инструкций. Добавление в архитектуру AMD64 восьми регистров GPR и увеличение ширины этих регистров с 32 бит до 64 бит позволяет компиляторам существенно повысить производительность программ. Компиляторы имеют большую гибкость в использовании регистров для хранения переменных. Кроме того, могут минимизировать трафик памяти и тем самым увеличить производительность за счет локализации работы в GPR.

### 1.1.3 Набор инструкций
Архитектура AMD64 поддерживает полный набор традиционных инструкций x86 с дополнительными инструкциями для поддержки длинного режима (см. таблицу 1-1 на стр. 2 для краткого описания режимов работы). Инструкции прикладного программирования разделены на четыре подмножества:

* *Инструкции общего назначения* (GPI) - это основные целочисленные инструкции x86, используемые практически во всех программах. Большинство этих инструкций загружают, сохраняют или оперируют данными, расположенными в регистрах общего назначения (GPRs) или в памяти. Некоторые из инструкций изменяют последовательный ход программы путем ветвления в другие места программы.

* Инструкции потоковых SIMD-расширений (SSE) - эти инструкции загружают, сохраняют или работают с данными, расположенными преимущественно в регистрах YMM/XMM. 128-битные мультимедийные инструкции работают с нижней половиной регистров YMM. Инструкции SSE выполняют целочисленные операции и операции с плавающей точкой над векторными (упакованными) и скалярными типами данных. Поскольку векторные инструкции могут независимо и одновременно выполнять одну операцию над несколькими наборами данных, они называются инструкциями с одной инструкцией и несколькими данными (SIMD). Они полезны для высокопроизводительных мультимедийных и научных приложений, оперирующих блоками данных.

* Инструкции расширения мультимедиа - включают инструкции технологии MMX™ и технологии AMD 3DNow!™. Эти инструкции загружают, сохраняют или оперируют данными, расположенными преимущественно в 64-битных регистрах MMX, которые отображаются на 80-битные регистры x87 с плавающей точкой. Как и инструкции SSE, они выполняют целочисленные операции и операции с плавающей точкой над векторными (упакованными) и скалярными данными типа. Эти инструкции полезны в мультимедийных приложениях, не требующих высокой точности. Инструкции Multimedia Extension Instructions используют насыщающие математические операции, которые не генерируют исключений операций. AMD отказалась от использования инструкций 3DNow!, которые были вытеснены их более эффективными аналогами SSE. Соответствующие рекомендации приведены в Главе 5, «Программирование 64-разрядных носителей» на странице 239, и в Руководстве программиста AMD64 Том 4: 64-разрядные носители и инструкции x87 с плавающей точкой.

* Инструкции x87 с плавающей точкой - это инструкции с плавающей точкой, используемые в устаревших приложениях x87. Они загружают, сохраняют или оперируют данными, расположенными в 80-битных регистрах x87.

Некоторые из этих инструкций прикладного программирования объединяют два или более подмножества. Например, есть инструкции, которые перемещают данные между регистрами общего назначения и регистрами YMM/XMM или MMX, а многие инструкции целочисленных векторов (упакованных) могут работать с регистрами YMM/XMM или MMX, хотя и не одновременно. Если инструкции пересекают два или более подмножеств, их описания повторяются во всех подмножествах, к которым они относятся.

### 1.1.4 Мультимедийные инструкции

Мультимедийные приложения, такие как обработка изображений, синтез музыки, распознавание речи, полноэкранное видео и рендеринг 3D-графики, имеют общие характеристики:

- Они обрабатывают большие объемы данных.
- Они часто выполняют одну и ту же последовательность операций над данными.
- Данные часто представляются в виде небольших величин, например 8 бит для значений пикселей, 16 бит для образцов звука и 32 бита для координат объектов в формате с плавающей точкой.

Инструкции SSE и MMX предназначены для ускорения работы этих приложений. Эти инструкции используют форму векторной (или пакетной) параллельной обработки, известную как обработка с одной инструкцией и несколькими данными (SIMD). Эта векторная технология имеет следующие характеристики:

- Один регистр может содержать несколько независимых частей данных. Например, один регистр YMM может содержать 32 8-битных целочисленных элемента данных или восемь 32-битных элементов данных с плавающей точкой одинарной точности.
- Векторные инструкции могут работать со всеми элементами данных в регистре, независимо и одновременно. Например, инструкция PADDB, работающая с байтовыми элементами двух операндов вектора в 128-битных регистрах XMM, выполняет 16 одновременных сложений и возвращает 16 независимых результатов за одну операцию.

Инструкции SSE и MMX делают еще один шаг вперед в развитии векторной технологии SIMD, включая специальные инструкции, которые выполняют операции, часто встречающиеся в мультимедийных приложениях. Например, графическое приложение, которое складывает значения яркости двух пикселей, должно предотвратить сворачивание операции сложения до маленького значения, если результат переполняет регистр назначения, поскольку результат переполнения может привести к неожиданным эффектам, таким как темный пиксель там, где ожидался светлый. Эти инструкции включают в себя насыщающие арифметические инструкции, упрощающие этот тип операций. Результат, который в противном случае обернулся бы вокруг из-за переполнения или недополнения, вместо этого принудительно насыщается по наибольшему или наименьшему значению, которое может быть представлено в регистре назначения.

### 1.1.5 Инструкции с плавающей точкой

Архитектура AMD64 предоставляет три подмножества инструкций с плавающей точкой, использующих три различных набора регистров:
* Инструкции SSE поддерживают 32-битные операции с плавающей точкой одинарной точности и 64-битные операции с плавающей точкой двойной точности, в дополнение к целочисленным операциям. Операции как с векторными, так и со скалярными данными поддерживаются по адресу, при этом имеется специальный механизм регистрации исключений операций с плавающей точкой. Эти операции с плавающей точкой соответствуют стандарту IEEE-754.
* Инструкции MMX поддерживают операции с плавающей точкой одинарной точности. Поддерживаются операции как с векторными данными, так и со скалярными данными, но эти инструкции не поддерживают отчет об исключениях с плавающей точкой.
* Инструкции x87 с плавающей точкой поддерживают операции с плавающей точкой одинарной точности, двойной точности и 80-битные операции с расширенной точностью. Поддерживаются только скалярные данные, а также специальный механизм регистрации исключений для операций с плавающей точкой. Инструкции x87 для операций с плавающей точкой содержат специальные инструкции для выполнения тригонометрических и логарифмических трансцендентных операций. Операции с плавающей точкой одинарной точности и двойной точности соответствуют стандарту IEEE-754.

Максимальная производительность операций с плавающей точкой достигается при использовании 256-битных векторных инструкций. Одна из этих векторных инструкций может поддерживать до восьми операций с одинарной точностью (или четырех с двойной точностью) параллельно. Всего 16 256-битных регистров YMM, доступных в 64-битном режиме, ускоряют работу приложений, предоставляя больше регистров для хранения промежуточных результатов, что уменьшает необходимость хранить эти результаты в памяти. Меньшее количество загрузок и сохранений обеспечивает более высокую производительность.

## 1.2 Режимы работы

В таблице 1-1 на странице 2 приведены режимы работы, поддерживаемые архитектурой AMD64. В большинстве случаев адреса и размеры операндов по умолчанию могут быть отменены с помощью префиксов инструкций. Расширения регистров, показанные во втором справа столбце таблицы 1-1, соответствуют тем, которые проиллюстрированы на Рисунок 1-1 на странице 2.

### 1.2.1 Длинный режим

Длинный режим - это расширение унаследованного защищенного режима. Длинный режим состоит из двух подрежимов: 64-битного режима и режима совместимости. 64-битный режим поддерживает все возможности и расширения регистров архитектуры AMD64. Режим совместимости поддерживает двоичную совместимость с существующими 16-битными и 32-битными приложениями. Длинный режим не поддерживает унаследованный реальный режим или унаследованный виртуальный режим 8086, а также не поддерживает аппаратное переключение задач.

В этом документе ссылки на длинный режим относятся как к 64-битному режиму, так и к режиму совместимости. Если функция специфична для одного из этих подрежимов, то вместо названия long mode используется название конкретного подрежима.

### 1.2.2 64-битный режим

64-битный режим - подрежим длинного режима - поддерживает весь спектр возможностей 64-битной виртуальной адресации и расширения регистров. Этот режим включается операционной системой на основе отдельных кодовых сегментов. Поскольку 64-битный режим поддерживает 64-битное виртуальное адресное пространство, он требует 64-битной операционной системы и цепочки инструментов. Существующие двоичные файлы приложений могут работать без перекомпиляции в режиме совместимости под управлением операционной системы, работающей в 64-битном режиме, или же приложения могут быть перекомпилированы для работы в 64-битном режиме.

Особенности адресации включают 64-битный указатель инструкций (RIP) и режим RIP-относительной адресации данных. В этом режиме современные операционные системы поддерживают только плоское адресное пространство, с единым пространством кода, данных и стека.

**Расширения регистров.** 64-битный режим реализует расширения регистров с помощью группы префиксов инструкций, называемых префиксами REX. Эти расширения добавляют восемь GPR (R8-R15), расширяют все GPR до 64 бит, и добавляют восемь регистров YMM/XMM (YMM/XMM8-15).

Префиксы инструкций REX также предоставляют возможность работы с байтными регистрами, благодаря чему младший байт любого из шестнадцати GPR доступен для байтовых операций. В результате получается унифицированный набор регистров: байт (byte), слово (word), двойное слово (doubleword) и четверное слово (quadword), который лучше подходит для распределения регистров компилятором.

**64-битные адреса и операнды.** В 64-битном режиме размер виртуального адреса по умолчанию составляет 64 бита (в реализации может быть меньше). Размер операнда по умолчанию для большинства инструкций равен 32 битам. Для большинства инструкций эти значения по умолчанию могут быть отменены для каждой инструкции с помощью префиксов. Префиксы REX определяют 64-битный размер операнда и расширения регистров.

**RIP-относительная адресация данных.** 64-битный режим поддерживает адресацию данных относительно 64-битного указателя инструкций (RIP). Унаследованная архитектура x86 поддерживает IP-относительную адресацию только в инструкциях передачи управления. Относительная RIP-адресация повышает эффективность позиционно-независимого кода и кода, обращающегося к глобальным данным.

**Опкоды.** Несколько операционных кодов инструкций и префиксных байтов переопределены, чтобы обеспечить расширение регистров и 64-битную адресацию. Эти различия описаны в Приложении B «Инструкции общего назначения в 64-битном режиме» и Приложении C «Различия между длинным режимом и режимом Legacy» в томе 3.

### 1.2.3 Режим совместимости

Режим совместимости - второй подрежим длинного режима - позволяет 64-битным операционным системам запускать существующие 16- и 32-битные приложения x86. Эти устаревшие приложения запускаются в режиме совместимости без перекомпиляции.

Приложения, работающие в режиме совместимости, используют 32- или 16-разрядную адресацию и могут получить доступ к первым 4 ГБ виртуального адресного пространства. Префиксы устаревших инструкций x86 позволяют переключаться между 16- и 32-разрядными адресами и размерами операндов.

Как и в 64-битном режиме, режим совместимости включается операционной системой на основе отдельных кодовых сегментов. Однако, в отличие от 64-битного режима, сегментация x86 функционирует так же, как и в унаследованной архитектуре x86, используя 16- или 32-битную семантику защищенного режима. С точки зрения приложений, режим совместимости выглядит как среда защищенного режима старой архитектуры x86. Однако с точки зрения операционной системы трансляция адресов, обработка прерываний и исключений, а также системные структуры данных используют 64-битные механизмы long-mode.

### 1.2.4 Legacy режим

Режим Legacy сохраняет бинарную совместимость не только с существующими 16- и 32-битными приложениями, но и с существующими 16- и 32-битными операционными системами. Режим Legacy состоит из следующих трех подрежимов:

* ***Защищенный режим*** - защищенный режим поддерживает 16- и 32-разрядные программы с сегментацией памяти, опциональной подкачкой и проверкой привилегий. Программы, работающие в защищенном режиме, могут получить доступ к 4 ГБ памяти по адресу.
* ***Режим Virtual-8086*** - Virtual-8086 поддерживает 16-разрядные программы реального режима, выполняемые как задачи в защищенном режиме. В нем используется простая форма сегментации памяти, опциональная подкачка и ограниченная проверка защиты. Программы, работающие в режиме virtual-8086, могут получить доступ к 1 МБ памяти.
* ***Реальный режим*** - Реальный режим поддерживает 16-битные программы, использующие простую сегментацию памяти на основе регистров. Он не поддерживает подкачку и проверку защиты. Программы, работающие в реальном режиме, могут получить доступ к памяти объемом до 1 МБ.

Режим Legacy совместим с существующими 32-разрядными процессорами, реализующими архитектуру x86. Процессоры, реализующие архитектуру AMD64, загружаются в унаследованном реальном режиме, как и процессоры, которые реализуют унаследованную архитектуру x86.

# 2. Модель памяти

## 2.1 Организация памяти

### 2.1.1 Виртуальная память

Виртуальная память состоит из всего адресного пространства, доступного программам. Это большое линейно-адресное пространство, которое преобразуется комбинацией аппаратных средств и программного обеспечения операционной системы в меньшее физическое адресное пространство, часть которого находится в памяти, а часть - на диске или другом внешнем носителе.

На рисунке 2-1 на странице 10 показано, как обрабатывается пространство виртуальной памяти в двух подрежимах длинного режима:

- *64-битный режим* - в этом режиме используется модель плоской сегментации виртуальной памяти. 64-битное пространство виртуальной памяти рассматривается как единое, плоское (несегментированное) адресное пространство. Адреса программы обращаются к местам, которые могут находиться в любом месте линейного 64-битного адресного пространства. Операционная система может использовать отдельные селекторы для сегментов кода, стека и данных в целях защиты памяти, но базовый адрес всех этих сегментов всегда равен 0. (Исключение из этого общего правила см. в разделе «FS и GS как база для вычисления адреса» на странице 17).

- *Режим совместимости* - в этом режиме используется защищенная многосегментная модель виртуальной памяти, как и в унаследованном защищенном режиме. 32-битное пространство виртуальной памяти рассматривается как сегментированный набор адресных пространств для сегментов кода, стека и данных, каждый из которых имеет свой базовый адрес и параметры защиты. Сегментированное пространство задается путем добавления к адресу селектора сегмента.

![[./Pasted image 20250629145705.png]]

Операционные системы используют сегментированную память как метод изоляции программ от данных, которые они используют, в попытке повысить надежность систем, в которых одновременно работают несколько программ. Однако большинство современных операционных систем не используют возможности сегментации, доступные в устаревшей архитектуре x86. Вместо этого эти операционные системы выполняют функции сегментации полностью программно. По этой причине архитектура AMD64 в 64-битном режиме обходится без большинства унаследованных функций сегментации. Это позволяет более просто кодировать 64-битные операционные системы и поддерживает более эффективное управление многозадачными средами, чем это возможно в устаревшей архитектуре x86.

### 2.1.2 Сегментные регистры

Сегментные регистры содержат селекторы, используемые для доступа к сегментам памяти. На рисунке 2-2 на странице 11 показана видимая приложению часть сегментных регистров. В унаследованном режиме и режиме совместимости все сегментные регистры доступны для программного обеспечения. В 64-битном режиме процессор распознает только сегменты CS, FS и GS, и программы могут использовать базовые регистры сегментов FS и GS в качестве базовых регистров для вычисления адреса, как описано в разделе «FS и GS как база для вычисления адреса» на странице 17. Для обращений к сегментам DS, ES или SS в 64-битном режиме процессор предполагает, что база каждого из этих сегментов равна нулю, не проверяются ни границы сегментов, ни их атрибуты, и процессор просто проверяет, что все такие адреса имеют каноническую форму, как описано в разделе «64-битные канонические адреса» на странице 15.

![[Pasted image 20250629150519.png]]

### 2.1.3 Физическая память

Физическая память - это установленная память (за исключением кэш-памяти) в конкретной компьютерной системе, доступ к которой возможен через шинный интерфейс процессора. Максимальный размер пространства физической памяти определяется с помощью адресных битов на шинном интерфейсе. В системе виртуальной памяти большое виртуальное адресное пространство (также называемое линейным адресным пространством) преобразуется в меньшее физическое адресное пространство с помощью комбинации аппаратных и программных средств сегментации и подкачки.

Сегментация показана на рисунке 2-1 на странице 10. Пейджинг - это механизм преобразования линейных (виртуальных) адресов в блоки фиксированного размера, называемые страницами, которые операционная система может перемещать по мере необходимости между памятью и внешними носителями (обычно дисками). Архитектура AMD64 поддерживает расширенную версию устаревшего механизма подкачки x86, которая способна преобразовывать полное 64-битное виртуальное адресное пространство в физическое адресное пространство, поддерживаемое конкретной реализацией.

### 2.1.4 Управление памятью

Стратегии управления памятью переводят адреса, генерируемые программами, в адреса в физической памяти с помощью сегментации и/или подкачки. Управление памятью не видно прикладным программам. Им занимаются операционная система и аппаратное обеспечение процессора. Ниже приводится очень краткий обзор этих функций. Более подробная информация приведена в разделе «Инструкции системного управления» в томе 2.

#### 2.1.4.1 Управление памятью в длинном режиме

На рисунке 2-3 показан поток, сверху вниз, функций управления памятью, выполняемых в двух подрежимах длинного режима.

![[Pasted image 20250629151331.png]]

В 64-битном режиме программы генерируют виртуальные (линейные) адреса, размер которых может достигать 64 бит. Виртуальные адреса передаются функции подкачки в длинном режиме, которая генерирует физические адреса, размер которых может достигать 52 бит. (Конкретные реализации архитектуры могут поддерживать меньшие размеры виртуальных и физических адресов).

В режиме совместимости устаревшие 16- и 32-битные приложения работают с использованием семантики сегментации в защищенном режиме x86. 16- или 32-битные эффективные адреса, генерируемые программами, объединяются с их сегментами для получения 32-битных виртуальных (линейных) адресов, которые расширяются до нуля и составляют максимум 64 бита. Последующая подкачка - это та же функция подкачки в длинном режиме, которая используется в 64-битном режиме. Она преобразует виртуальные адреса в физические. Комбинация селектора сегмента и эффективного адреса также называется *логическим адресом* или *дальним указателем*. *Виртуальный адрес* также называется линейным адресом.

#### 2.1.4.2 Управление памяти в устаревшем режиме (Legacy mode)

На рисунке 2-4 на странице 13 показаны функции управления памятью, выполняемые в трех подрежимах устаревшего режима.

![[Pasted image 20250629152126.png]]

В зависимости от подрежима функции управления памятью различаются следующим образом:
- *Защищенный режим* - защищенный режим поддерживает 16- и 32-битные программы с табличной сегментацией памяти, подкачкой и проверкой привилегий. Функция сегментации принимает 32-битные эффективные адреса и 16-битные селекторы сегментов и выдает 32-битные линейные адреса в один из 16K сегментов памяти, каждый из которых может быть размером до 4 ГБ. Подкачка необязательна. 32-битные физические адреса либо создаются функцией подкачки, либо линейные адреса используются без модификации в качестве физических адресов.
- *Режим Virtual-8086* - режим Virtual-8086 поддерживает 16-разрядные программы, выполняемые как задачи в защищенном режиме. 20-битные линейные адреса формируются так же, как и в реальном режиме, но по желанию могут быть транслированы через функцию подкачки для формирования 32-битных физических адресов, обеспечивающих доступ к памяти объемом до 4 ГБ.
- *Реальный режим* - данный режим поддерживает 16-битные программы, использующие регистровую сегментацию со сдвигом и добавлением, но не поддерживает подкачку. Шестнадцатибитные эффективные адреса расширяются до нуля и добавляются к 16-битному адресу сегмента-базы, который сдвигается на четыре бита влево, в результате чего получается 20-битный линейный адрес. Линейный адрес расширяется до 32-битного физического адреса, по которому можно получить доступ к памяти объемом до 1 МБ.

## 2.2 Адресация памяти

### 2.2.1 Очередь байт

Инструкции и данные хранятся в памяти в *little-endian* порядке байт. Младший порядок помещает наименее значимый байт инструкции или элемента данных по младшему адресу памяти, а наиболее значимый байт - по старшему адресу памяти.

На рисунке 2-5 показано обобщение little-endian памяти и регистровых образов типа данных quadword. Младший байт находится по младшему адресу в памяти и по крайнему правому в образе регистра.

![[Pasted image 20250629153001.png]]

На рисунке 2-6 на странице 15 показан образ памяти для 10-байтовой инструкции. Инструкции относятся к байтовым типам данных. Они считываются из памяти по одному байту за раз, начиная с наименьшего значащего байта (младшего адреса). Например, следующая инструкция задает 64-битную инструкцию MOV RAX, 1122334455667788, состоящую из следующих десяти байт:

```
48 B8 8877665544332211
```

48 - префикс инструкции REX, задающий 64-битный размер операнда, B8 - опкод, который вместе с префиксом REX определяет 64-битный регистр назначения RAX, а 8877665544332211 - 8-байтовое непосредственное значение для перемещения, где 88 представляет восьмой (наименее значащий) байт, а 11 - первый (наиболее значащий) байт. В памяти байт префикса REX (48) будет храниться по младшему адресу, а первый непосредственный байт (11) - по старшему адресу инструкции

![[Pasted image 20250629153308.png]]

### 2.2.2 Каноничные 64-битные адреса

Длинный режим определяет 64 бита виртуального адреса, но реализации архитектуры AMD64 могут поддерживать меньшее количество битов виртуального адреса. Хотя реализации могут не использовать все 64 бита виртуального адреса, они проверяют биты с 63 по самый значимый реализованный бит, чтобы убедиться, что в этих битах все нули или все единицы. Адрес, удовлетворяющий этому свойству, считается *адресом в канонической форме*. Если ссылка на виртуальную память не имеет канонической формы, реализация вызывает исключение общей защиты или ошибку стека.

### 2.2.3 Эффективные адреса
